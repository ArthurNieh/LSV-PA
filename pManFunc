src/map/if/ifTune.c:    for ( i = pNtk->nInps; i < pNtk->nObjs; i++ )
src/map/if/ifTune.c:        if ( pNtk->Nodes[i].Type == IFN_DSD_PRIME )
src/map/if/ifTune.c:            Counter += (1 << pNtk->Nodes[i].nFanins);
src/map/cov/covMan.c:    assert( pNtk->pManCut == NULL );
src/map/cov/covCore.c:    pNtk->pManCut = p;
src/map/cov/covCore.c:    pNtk->pManCut = NULL;
src/map/cov/cov.h:static inline Cov_Obj_t *  Abc_ObjGetStr( Abc_Obj_t * pObj )                       { return (Cov_Obj_t *)Vec_PtrEntry(((Cov_Man_t *)pObj->pNtk->pManCut)->vObjStrs, pObj->Id); }
src/map/scl/sclUtil.c:    pBuffer = Mio_LibraryReadBuf( (Mio_Library_t *)pNtk->pManFunc );
src/map/scl/sclUpsize.c:        if ( p->pNtk->vPhases == NULL )
src/map/scl/sclUpsize.c:        if ( p->pNtk->vPhases == NULL )
src/map/scl/sclUpsize.c:        if ( p->pNtk->vPhases && Abc_SclIsInv(pBuf) )
src/map/scl/sclUpsize.c:        if ( pNtk->vPhases && Abc_SclIsInv(pObj) )
src/map/scl/sclUpsize.c:    p->vGatesBest = Vec_IntDup( p->pNtk->vGates );
src/map/scl/sclUpsize.c:            Abc_SclApplyUpdateToBest( p->vGatesBest, p->pNtk->vGates, p->vUpdates );
src/map/scl/sclUpsize.c:    ABC_SWAP( Vec_Int_t *, p->vGatesBest, p->pNtk->vGates );
src/map/scl/sclUpsize.c:    if ( pNtk->nBarBufs2 > 0 )
src/map/scl/sclUpsize.c:    if ( pNtk->nBarBufs2 > 0 )
src/map/scl/sclUpsize.c:    if ( pNtk->nBarBufs2 > 0 )
src/map/scl/sclBufSize.c:static inline Bus_Man_t * Bus_SclObjMan( Abc_Obj_t * p )                     { return (Bus_Man_t *)p->pNtk->pBSMan;                                  }
src/map/scl/sclBufSize.c:        if ( pNtk->pWLoadUsed == NULL )
src/map/scl/sclBufSize.c:            pNtk->pWLoadUsed = Abc_UtilStrsav( p->pWLoadUsed->pName );
src/map/scl/sclBufSize.c:            p->pWLoadUsed = Abc_SclFetchWireLoadModel( pLib, pNtk->pWLoadUsed );
src/map/scl/sclBufSize.c:    pNtk->pBSMan = p;
src/map/scl/sclBufSize.c:        if ( pObj->pNtk->vPhases )
src/map/scl/sclBufSize.c:    Vec_IntSetEntry( p->pNtk->vGates, Abc_ObjId(pInv), pCellNew->Id );
src/map/scl/sclBufSize.c:    if ( p->pNtk->vPhases && Abc_SclIsInv(pInv) )
src/map/scl/sclBufSize.c:    if ( pNtk->vPhases )
src/map/scl/sclBufSize.c:        Vec_IntFillExtra( pNtk->vPhases, Abc_NtkObjNumMax(pNtk), 0 );
src/map/scl/sclDnsize.c:    p->vGatesBest = Vec_IntDup( p->pNtk->vGates );
src/map/scl/sclDnsize.c:    if ( pNtk->nBarBufs2 > 0 )
src/map/scl/sclDnsize.c:    if ( pNtk->nBarBufs2 > 0 )
src/map/scl/sclDnsize.c:    if ( pNtk->nBarBufs2 > 0 )
src/map/scl/sclSize.h:static inline SC_Lib  * Abc_SclObjLib( Abc_Obj_t * p )                              { return (SC_Lib *)p->pNtk->pSCLib;    }
src/map/scl/sclSize.h:static inline int       Abc_SclObjCellId( Abc_Obj_t * p )                           { return Vec_IntEntry( p->pNtk->vGates, Abc_ObjId(p) );                               }
src/map/scl/sclSize.h:static inline void      Abc_SclObjSetCell( Abc_Obj_t * p, SC_Cell * pCell )         { Vec_IntWriteEntry( p->pNtk->vGates, Abc_ObjId(p), pCell->Id );                      }
src/map/scl/sclSize.h:    p->pNtk->pSCLib = NULL;
src/map/scl/sclSize.h:    Vec_IntFreeP( &p->pNtk->vGates );
src/map/scl/sclSize.h:    if ( strcmp( FileNameOld, p->pNtk->pName ) )
src/map/scl/sclSize.h:        sprintf( FileNameOld, "%s", p->pNtk->pName );
src/map/scl/sclSize.h:        fprintf( pTable, "%s ", Extra_FileNameWithoutPath(p->pNtk->pName) );
src/map/scl/scl.c:    if ( !pPars->fSizeOnly && !pPars->fAddBufs && pNtk->vPhases == NULL )
src/map/scl/scl.c:    if ( fAddInvs && pNtk->vPhases == NULL )
src/map/scl/sclSize.c:        if ( pNtk->pWLoadUsed == NULL )
src/map/scl/sclSize.c:            pNtk->pWLoadUsed = Abc_UtilStrsav( p->pWLoadUsed->pName );
src/map/scl/sclSize.c:            p->pWLoadUsed = Abc_SclFetchWireLoadModel( pLib, pNtk->pWLoadUsed );
src/map/scl/sclSize.c:    if ( pNtk->nBarBufs2 > 0 )
src/map/scl/sclSize.c:    if ( pNtk->nBarBufs2 > 0 )
src/map/scl/sclBuffer.c:    assert( pNtk->vPhases != NULL );
src/map/scl/sclBuffer.c:    Vec_IntFillExtra( pNtk->vPhases, Abc_NtkObjNumMax(pNtk), 0 );
src/map/scl/sclBuffer.c:    vInvs = pNtk->vPhases;
src/map/scl/sclBuffer.c:    pNtk->vPhases = NULL;
src/map/scl/sclBuffer.c:    pNtk->vPhases = vInvs;
src/map/scl/sclBuffer.c:    assert( pNtk->vPhases == NULL );
src/map/scl/sclBuffer.c:    pNtk->vPhases = Vec_IntStart( Abc_NtkObjNumMax(pNtk) );
src/map/scl/sclBuffer.c:    p->DelayInv  = Mio_GateReadPinDelay( Mio_LibraryReadInv((Mio_Library_t *)pNtk->pManFunc), 0 );
src/map/scl/sclBuffer.c:        assert( pObj->pData == Mio_LibraryReadBuf((Mio_Library_t *)pNtk->pManFunc) );
src/map/scl/sclBuffer.c:        pObj->pData = Mio_LibraryReadInv((Mio_Library_t *)pNtk->pManFunc);
src/map/scl/sclBuffer.c:            pObj->pData = Mio_LibraryReadInv((Mio_Library_t *)p->pNtk->pManFunc);
src/map/mpm/mpmGates.c:    pNtk->pName = Extra_UtilStrsav( p->pMig->pName );
src/map/mpm/mpmGates.c:    pNtk->pManFunc = pMio;
src/map/amap/amapPerm.c:    if ( Abc_LitIsCompl(pNtk->Root) )
src/map/amap/amapPerm.c:    vPerm = Amap_LibDeriveGatePerm_rec( pLib, pNtk, Abc_LitRegular(pNtk->Root), pNod );
src/proof/live/kliveness.c:    pNtk->pManName = Nm_ManCreate( Abc_NtkCiNum( pNtk ) );
src/proof/live/kliveness.c:            Nm_ManStoreIdName( pNtk->pManName, ntkObjId, Aig_ObjType(pObj), (char *)Vec_PtrEntry(vPiNames, i), NULL );
src/proof/live/kliveness.c:            Nm_ManStoreIdName( pNtk->pManName, ntkObjId, Aig_ObjType(pObj), (char *)Vec_PtrEntry(vLoNames, i), NULL );
src/proof/live/kliveness.c:            Nm_ManStoreIdName( pNtk->pManName, ntkObjId, Aig_ObjType(pObj), (char *)Vec_PtrEntry(vPoNames, i), NULL );    
src/proof/live/kliveness.c:            Nm_ManStoreIdName( pNtk->pManName, ntkObjId, Aig_ObjType(pObj), (char *)Vec_PtrEntry(vLiNames, i), NULL );
src/proof/live/kliveness.c:        if ( Nm_ManFindNameById(pNtk->pManName, Abc_ObjFanin0(pNode)->Id) == NULL )
src/proof/live/liveness_sim.c:    pNtk->pManName = Nm_ManCreate( Abc_NtkCiNum( pNtk ) );
src/proof/live/liveness_sim.c:        //printf("Pi %d, Saved Name = %s, id = %d\n", i, Nm_ManStoreIdName( pNtk->pManName, ntkObjId, Aig_ObjType(pObj), Vec_PtrEntry(vPiNames, i), NULL ), ntkObjId);  
src/proof/live/liveness_sim.c:        Nm_ManStoreIdName( pNtk->pManName, ntkObjId, Aig_ObjType(pObj), (char *)Vec_PtrEntry(vPiNames, i), NULL );
src/proof/live/liveness_sim.c:        //printf("Lo %d, Saved name = %s, id = %d\n", i, Nm_ManStoreIdName( pNtk->pManName, ntkObjId, Aig_ObjType(pObj), Vec_PtrEntry(vLoNames, i), NULL ), ntkObjId);  
src/proof/live/liveness_sim.c:        Nm_ManStoreIdName( pNtk->pManName, ntkObjId, Aig_ObjType(pObj), (char *)Vec_PtrEntry(vLoNames, i), NULL );
src/proof/live/liveness.c:    pNew->pName = (char *)malloc( strlen( pNtk->pName ) + strlen("_l2s") + 1 );
src/proof/live/liveness.c:    sprintf(pNew->pName, "%s_%s", pNtk->pName, "l2s");
src/proof/live/liveness.c:    pNew->pName = (char *)malloc( strlen( pNtk->pName ) + strlen("_l2s") + 1 );
src/proof/live/liveness.c:    sprintf(pNew->pName, "%s_%s", pNtk->pName, "l2s");
src/proof/live/liveness.c:    pNtk->pManName = Nm_ManCreate( Abc_NtkCiNum( pNtk ) );
src/proof/live/liveness.c:            //printf("Pi %d, Saved Name = %s, id = %d\n", i, Nm_ManStoreIdName( pNtk->pManName, ntkObjId, Aig_ObjType(pObj), Vec_PtrEntry(vPiNames, i), NULL ), ntkObjId);  
src/proof/live/liveness.c:            Nm_ManStoreIdName( pNtk->pManName, ntkObjId, Aig_ObjType(pObj), (char *)Vec_PtrEntry(vPiNames, i), NULL );
src/proof/live/liveness.c:            //printf("Lo %d, Saved name = %s, id = %d\n", i, Nm_ManStoreIdName( pNtk->pManName, ntkObjId, Aig_ObjType(pObj), Vec_PtrEntry(vLoNames, i), NULL ), ntkObjId);  
src/proof/live/liveness.c:            Nm_ManStoreIdName( pNtk->pManName, ntkObjId, Aig_ObjType(pObj), (char *)Vec_PtrEntry(vLoNames, i), NULL );
src/proof/live/liveness.c:        if ( Nm_ManFindNameById(pNtk->pManName, Abc_ObjFanin0(pNode)->Id) == NULL )
src/proof/live/liveness.c:    //Vec_PtrForEachEntry( char *, pNtk->vLtlProperties, pFormula, i )
src/proof/live/liveness.c:        //vecInputLtlFormulae = pNtk->vLtlProperties;
src/proof/live/liveness.c:        pNew->pName = (char *)malloc( strlen( pNtk->pName ) + strlen("_l3s") + 1 );
src/proof/live/liveness.c:        sprintf(pNew->pName, "%s_%s", pNtk->pName, "l3s");
src/proof/live/ltl_parser.c:    pAbc->vLTLProperties_global = Vec_PtrAlloc(Vec_PtrSize(pNtk->vLtlProperties));
src/proof/live/ltl_parser.c:    Vec_PtrForEachEntry( char *, pNtk->vLtlProperties, pLtlFormula, i )
src/proof/pdr/pdrIncr.c:                Abc_Print( 1, "Output %d of miter \"%s\" was asserted in frame %d.  ", pMan->pSeqModel->iPo, pNtk->pName, pMan->pSeqModel->iFrame );
src/proof/pdr/pdrIncr.c:    ABC_FREE( pNtk->pSeqModel );
src/proof/pdr/pdrIncr.c:    pNtk->pSeqModel = pMan->pSeqModel;
src/proof/pdr/pdrIncr.c:    if ( pNtk->vSeqModelVec )
src/proof/pdr/pdrIncr.c:        Vec_PtrFreeFree( pNtk->vSeqModelVec );
src/proof/pdr/pdrIncr.c:    pNtk->vSeqModelVec = pMan->vSeqModelVec;
src/ext-lsv/lsvCmd.cpp:    DdManager * dd = (DdManager *)pRoot->pNtk->pManFunc;  
src/opt/cut/abcCut.c://    Cut_ManPrintStatsToFile( p, pNtk->pSpec, clock() - clk );
src/opt/ret/retIncrem.c:    vBoxes = pNtk->vBoxes;  pNtk->vBoxes = NULL;
src/opt/ret/retIncrem.c:    pNtk->vBoxes = vBoxes;
src/opt/ret/retIncrem.c:    vCisOld   = pNtk->vCis;    pNtk->vCis   = NULL;  vCisNew   = Vec_PtrAlloc( 100 );
src/opt/ret/retIncrem.c:    vCosOld   = pNtk->vCos;    pNtk->vCos   = NULL;  vCosNew   = Vec_PtrAlloc( 100 );  
src/opt/ret/retIncrem.c:    vBoxesOld = pNtk->vBoxes;  pNtk->vBoxes = NULL;  vBoxesNew = Vec_PtrAlloc( 100 );
src/opt/ret/retIncrem.c:    pNtk->vCis   = vCisNew;   Vec_PtrFree( vCisOld );
src/opt/ret/retIncrem.c:    pNtk->vCos   = vCosNew;   Vec_PtrFree( vCosOld );
src/opt/ret/retIncrem.c:    pNtk->vBoxes = vBoxesNew; Vec_PtrFree( vBoxesOld );
src/opt/ret/retArea.c:    assert( Abc_NtkLatchNum(pNtk) == Vec_PtrSize(pNtk->vBoxes) );
src/opt/ret/retArea.c:    Vec_PtrShrink( pNtk->vCis, Abc_NtkCiNum(pNtk) - Abc_NtkLatchNum(pNtk) );
src/opt/ret/retArea.c:    Vec_PtrShrink( pNtk->vCos, Abc_NtkCoNum(pNtk) - Abc_NtkLatchNum(pNtk) );
src/opt/ret/retArea.c:    vCis   = pNtk->vCis;   pNtk->vCis   = NULL;  
src/opt/ret/retArea.c:    vCos   = pNtk->vCos;   pNtk->vCos   = NULL;  
src/opt/ret/retArea.c:    vBoxes = pNtk->vBoxes; pNtk->vBoxes = NULL; 
src/opt/ret/retArea.c:    pNtk->vCis = vCis;
src/opt/ret/retArea.c:    pNtk->vCos = vCos;
src/opt/ret/retArea.c:    pNtk->vBoxes = vBoxesNew;
src/opt/ret/retFlow.c:        Vec_PtrForEachEntry( Abc_Obj_t *, pNtk->vBoxes, pLatch, i )
src/opt/ret/retFlow.c:        Vec_PtrForEachEntry( Abc_Obj_t *, pNtk->vBoxes, pLatch, i )
src/opt/nwk/nwkDfs.c:            if ( pNtk->pManTime )
src/opt/nwk/nwkDfs.c:                iBox = Tim_ManBoxForCi( pNtk->pManTime, pObj->PioId );
src/opt/nwk/nwkDfs.c:                    iTerm1 = Tim_ManBoxInputFirst( pNtk->pManTime, iBox );
src/opt/nwk/nwkDfs.c:                    nTerms = Tim_ManBoxInputNum( pNtk->pManTime, iBox );
src/opt/nwk/nwkDfs.c:    pManTimeUnit = pNtk->pManTime ? Tim_ManDup( pNtk->pManTime, 1 ) : NULL;
src/opt/nwk/nwkTiming.c:    If_LibLut_t * pLutLib = pNtk->pLutLib;
src/opt/nwk/nwkTiming.c:    if ( pNtk->pManTime )
src/opt/nwk/nwkTiming.c:        Tim_ManIncrementTravId( pNtk->pManTime );
src/opt/nwk/nwkTiming.c:        if ( Nwk_ObjIsCi(pObj) && pNtk->pManTime )
src/opt/nwk/nwkTiming.c:            tArrival = Tim_ManGetCiArrival( pNtk->pManTime, pObj->PioId );
src/opt/nwk/nwkTiming.c:        if ( Nwk_ObjIsCo(pObj) && pNtk->pManTime )
src/opt/nwk/nwkTiming.c:            Tim_ManSetCoArrival( pNtk->pManTime, pObj->PioId, tArrival );
src/opt/nwk/nwkTiming.c:    if ( pNtk->pManTime )
src/opt/nwk/nwkTiming.c:        Tim_ManIncrementTravId( pNtk->pManTime );
src/opt/nwk/nwkTiming.c:        Tim_ManInitPoRequiredAll( pNtk->pManTime, tArrival );
src/opt/nwk/nwkTiming.c:            if ( pNtk->pManTime )
src/opt/nwk/nwkTiming.c:                Tim_ManSetCiRequired( pNtk->pManTime, pObj->PioId, Nwk_ObjRequired(pObj) );
src/opt/nwk/nwkTiming.c:            if ( pNtk->pManTime )
src/opt/nwk/nwkTiming.c:                tRequired = Tim_ManGetCoRequired( pNtk->pManTime, pObj->PioId );
src/opt/nwk/nwkTiming.c:    If_LibLut_t * pLutLib = pNtk->pLutLib;
src/opt/nwk/nwkSpeedup.c:    If_LibLut_t * pLutLib = fUseLutLib? pNtk->pLutLib : NULL;
src/opt/nwk/nwkSpeedup.c:    If_LibLut_t * pTempLib = pNtk->pLutLib;
src/opt/nwk/nwkSpeedup.c:        pNtk->pLutLib = NULL;
src/opt/nwk/nwkSpeedup.c:        if ( pNtk->pManTime )
src/opt/nwk/nwkSpeedup.c:            pTempTim = pNtk->pManTime;
src/opt/nwk/nwkSpeedup.c:            pNtk->pManTime = Tim_ManDup( pTempTim, 1 );
src/opt/nwk/nwkSpeedup.c:        pNtk->pLutLib = pTempLib;
src/opt/nwk/nwkSpeedup.c:        Tim_ManStop( pNtk->pManTime );
src/opt/nwk/nwkSpeedup.c:        pNtk->pManTime = pTempTim;
src/opt/nwk/nwkAig.c:    pNtk->nFanioPlus = 0;
src/opt/nwk/nwkAig.c:    Hop_ManStop( pNtk->pManHop );
src/opt/nwk/nwkAig.c:    pNtk->pManHop = NULL;
src/opt/nwk/nwkAig.c:    pNtk->pName = Abc_UtilStrsav( p->pName );
src/opt/nwk/nwkAig.c:    pNtk->pSpec = Abc_UtilStrsav( p->pSpec );
src/opt/nwk/nwkAig.c:    pNtk->pName = Abc_UtilStrsav( p->pName );
src/opt/nwk/nwkAig.c:    pNtk->nFanioPlus = 0;
src/opt/nwk/nwkAig.c:    Hop_ManStop( pNtk->pManHop );
src/opt/nwk/nwkAig.c:    pNtk->pManHop = NULL;
src/opt/nwk/nwkBidec.c:        pObj->pFunc = Nwk_NodeIfNodeResyn( p, pNtk->pManHop, pObj->pFunc, Nwk_ObjFaninNum(pObj), vTruth, NULL, -1.0 );
src/opt/nwk/nwkFlow.c:// pObj->TravId  < pNtk->nTravIds-2   --- not visited
src/opt/nwk/nwkFlow.c:// pObj->TravId == pNtk->nTravIds-2   --- visited bot only
src/opt/nwk/nwkFlow.c:// pObj->TravId == pNtk->nTravIds-1   --- visited top only
src/opt/nwk/nwkFlow.c:// pObj->TravId == pNtk->nTravIds     --- visited bot and top
src/opt/nwk/nwkMan.c:          strcmp(ParsBest.pName, pNtk->pName) ||
src/opt/nwk/nwkMan.c:        ParsBest.pName = Abc_UtilStrsav( pNtk->pName );
src/opt/nwk/nwkMan.c:        const char * pNameGen = pNtk->pSpec? Nwk_FileNameGeneric( pNtk->pSpec ) : "nameless_";
src/opt/nwk/nwkMan.c:        if ( pNtk->pSpec ) ABC_FREE( pNameGen );
src/opt/nwk/nwkMan.c:    pNtk->pLutLib = pLutLib;
src/opt/nwk/nwkMan.c:    printf( "%-15s : ",      pNtk->pName );
src/opt/nwk/nwkFlow_depth.c:// pObj->TravId  < pNtk->nTravIds-2   --- not visited
src/opt/nwk/nwkFlow_depth.c:// pObj->TravId == pNtk->nTravIds-2   --- visited bot only
src/opt/nwk/nwkFlow_depth.c:// pObj->TravId == pNtk->nTravIds-1   --- visited top only
src/opt/nwk/nwkFlow_depth.c:// pObj->TravId == pNtk->nTravIds     --- visited bot and top
src/opt/nwk/nwkUtil.c:    if ( pNtk->nTravIds >= (1<<26)-1 )
src/opt/nwk/nwkUtil.c:        pNtk->nTravIds = 0;
src/opt/nwk/nwkUtil.c:    pNtk->nTravIds++;
src/opt/nwk/nwkUtil.c:    fprintf( pFile, ".model %s\n", pNtk->pName );
src/opt/nwk/nwkUtil.c:        pTruth = Hop_ManConvertAigToTruth( pNtk->pManHop, Hop_Regular(pObj->pFunc), Nwk_ObjFaninNum(pObj), vTruth, 0 );
src/opt/nwk/nwkUtil.c:    pTruth = Hop_ManConvertAigToTruth( pNtk->pManHop, Hop_Regular(pObj->pFunc), Nwk_ObjFaninNum(pObj), vTruth, 0 );
src/opt/nwk/nwkUtil.c:    pObjNew->pFunc = Hop_Remap( pNtk->pManHop, pObj->pFunc, uSupp, Nwk_ObjFaninNum(pObj) );
src/opt/nwk/nwkStrash.c:    pMan->pName = Abc_UtilStrsav( pNtk->pName );
src/opt/nwk/nwkStrash.c:    pMan->pSpec = Abc_UtilStrsav( pNtk->pSpec );
src/opt/nwk/nwkStrash.c:    pMan->pManTime = Tim_ManDup( (Tim_Man_t *)pNtk->pManTime, 1 );
src/opt/nwk/nwkMap.c:    pNtk->pName = Abc_UtilStrsav( p->pName );
src/opt/nwk/nwkMap.c:    pNtk->pSpec = Abc_UtilStrsav( p->pSpec );
src/opt/nwk/nwkMap.c://    pNtk->nLatches = Aig_ManRegNum(p);
src/opt/nwk/nwkMap.c://    pNtk->nTruePis = Nwk_ManCiNum(pNtk) - pNtk->nLatches;
src/opt/nwk/nwkMap.c://    pNtk->nTruePos = Nwk_ManCoNum(pNtk) - pNtk->nLatches;
src/opt/nwk/nwkMap.c:            pObjNew->pFunc = Nwk_NodeIfToHop( pNtk->pManHop, pIfMan, pIfObj );
src/opt/nwk/nwkMap.c:            pObjNew->pFunc = Hop_ManConst1( pNtk->pManHop );
src/opt/nwk/nwkMap.c:    pNtk->pManTime = Tim_ManDup( pIfMan->pManTim, 0 );
src/opt/fret/fretMain.c:      if (Nm_ManFindNameById(pNtk->pManName, Abc_ObjId(pBi)))
src/opt/fret/fretMain.c:        Nm_ManDeleteIdName( pNtk->pManName, Abc_ObjId(pBi));
src/opt/fret/fretMain.c:      if (Nm_ManFindNameById(pNtk->pManName, Abc_ObjId(pBo)))
src/opt/fret/fretMain.c:        Nm_ManDeleteIdName( pNtk->pManName, Abc_ObjId(pBo));
src/opt/fret/fretMain.c:    if (Nm_ManFindNameById(pNtk->pManName, Abc_ObjId(pObj)))
src/opt/fret/fretMain.c:      Nm_ManDeleteIdName( pNtk->pManName, Abc_ObjId(pObj));
src/opt/fret/fretMain.c:  pNtkCopy = Abc_NtkAlloc( pNtk->ntkType, pNtk->ntkFunc, 1 );
src/opt/fret/fretMain.c:  pNtkCopy->pName = Extra_UtilStrsav(pNtk->pName);
src/opt/fret/fretMain.c:  pNtkCopy->pSpec = Extra_UtilStrsav(pNtk->pSpec);
src/opt/fret/fretMain.c:    if ( pNtk->pExdc )
src/opt/fret/fretMain.c:      pNtkAig->pExdc = Abc_NtkDup( pNtk->pExdc );
src/opt/fret/fretInit.c:  DdManager * dd = (DdManager*)pNtk->pManFunc;
src/opt/fret/fretInit.c:  Hop_Man_t *pHop = (Hop_Man_t*)pNtk->pManFunc;
src/opt/fret/fretInit.c:    pManMR->pInitNtk = Abc_NtkAlloc( pNtk->ntkType, ABC_FUNC_SOP, 1 );
src/opt/fret/fretInit.c:    pManMR->pInitNtk = Abc_NtkAlloc( pNtk->ntkType, pNtk->ntkFunc, 1 );
src/opt/sim/simSymStr.c:    pNtk->vSupps = Sim_ComputeStrSupp( pNtk );
src/opt/sim/simSymStr.c:    Sim_UtilInfoFree( pNtk->vSupps );
src/opt/sim/simSymStr.c:    pNtk->vSupps = NULL;
src/opt/sim/simSymStr.c:        fIsVar1 = Sim_SuppStrHasVar( pNtk->vSupps, pNode, Ind1 );
src/opt/sim/simSymStr.c:        fIsVar2 = Sim_SuppStrHasVar( pNtk->vSupps, pNode, Ind2 );
src/opt/res/resCore.c:            pFunc = p->pSim->fConst1? Hop_ManConst1((Hop_Man_t *)pNtk->pManFunc) : Hop_ManConst0((Hop_Man_t *)pNtk->pManFunc);
src/opt/res/resCore.c:            pFunc = Kit_GraphToHop( (Hop_Man_t *)pNtk->pManFunc, pGraph );
src/opt/mfs/mfsStrash.c:// should be called as follows:   pNodeNew->pData = Abc_MfsConvertAigToHop( pAigManInterpol, pNodeNew->pNtk->pManFunc );
src/opt/mfs/mfsStrash.c:    pHopMan = (Hop_Man_t *)pObjOld->pNtk->pManFunc;
src/opt/mfs/mfsInter.c:    pFunc = Kit_GraphToHop( (Hop_Man_t *)p->pNtk->pManFunc, pGraph );
src/opt/mfs/mfsCore_.c:    pObj = Abc_NodeIfNodeResyn( p->pManDec, pNode->pNtk->pManFunc, pNode->pData, p->nFanins, p->vTruth, p->uCare, dProb );
src/opt/mfs/mfsCore_.c:    if ( pNtk->pExcare )
src/opt/mfs/mfsCore_.c:        if ( Abc_NtkPiNum(pNtk->pExcare) != Abc_NtkCiNum(pNtk) )
src/opt/mfs/mfsCore_.c:                Abc_NtkPiNum(pNtk->pExcare), Abc_NtkCiNum(pNtk) );
src/opt/mfs/mfsCore_.c:            pTemp = Abc_NtkStrash( pNtk->pExcare, 0, 0, 0 );
src/opt/mfs/mfsCore.c:    pObj = Abc_NodeIfNodeResyn( p->pManDec, (Hop_Man_t *)pNode->pNtk->pManFunc, (Hop_Obj_t *)pNode->pData, p->nFanins, p->vTruth, p->uCare, dProb );
src/opt/mfs/mfsCore.c:    if ( pNtk->pExcare )
src/opt/mfs/mfsCore.c:        if ( Abc_NtkPiNum((Abc_Ntk_t *)pNtk->pExcare) != Abc_NtkCiNum(pNtk) )
src/opt/mfs/mfsCore.c:                Abc_NtkPiNum((Abc_Ntk_t *)pNtk->pExcare), Abc_NtkCiNum(pNtk) );
src/opt/mfs/mfsCore.c:            pTemp = Abc_NtkStrash( (Abc_Ntk_t *)pNtk->pExcare, 0, 0, 0 );
src/opt/lpk/lpkCore.c:        if ( Abc_LitIsCompl(pNtk->Root) )
src/opt/lpk/lpkCore.c:        if ( Abc_LitIsCompl(pNtk->Root) ^ Abc_LitIsCompl(pRoot->pFans[0]) )
src/opt/lpk/lpkCore.c:    pDriver = Lpk_MapTree_rec( p, pNtk, ppLeaves, pNtk->Root, NULL );
src/opt/lpk/lpkCore.c:    p->vLevels = Vec_VecStart( pNtk->LevelMax ); 
src/opt/lpk/lpkCut.c:    Hop_Man_t * pManHop = (Hop_Man_t *)p->pNtk->pManFunc;
src/opt/lpk/lpkCut.c:    Hop_Man_t * pManHop = (Hop_Man_t *)p->pNtk->pManFunc;
src/opt/lpk/lpkAbcDec.c:        pObjNew->pData = Hop_NotCond( Hop_ManConst1((Hop_Man_t *)pNtk->pManFunc), !(pTruth[0] & 1) );
src/opt/lpk/lpkAbcDec.c:        pObjNew->pData = Hop_NotCond( Hop_ManPi((Hop_Man_t *)pNtk->pManFunc, 0), (pTruth[0] & 1) );
src/opt/lpk/lpkAbcDec.c:    pObjNew->pData = Kit_TruthToHop( (Hop_Man_t *)pNtk->pManFunc, pTruth, p->nVars, NULL );
src/opt/dau/dauTree.c:        return Abc_Var2Lit( Dss_ObjId(Dss_VecVar(pNtk->vObjs, **p - 'a')), fCompl );
src/opt/dau/dauTree.c:        pNtk->pRoot = Dss_VecConst0(pNtk->vObjs);
src/opt/dau/dauTree.c:        pNtk->pRoot = Dss_VecVar(pNtk->vObjs, Dau_DsdReadVar(pDsd));
src/opt/dau/dauTree.c:        pNtk->pRoot = Dss_Lit2Obj( pNtk->vObjs, iLit );
src/opt/dau/dauTree.c:        pNtk->pRoot = Dss_Not(pNtk->pRoot);
src/opt/dau/dauTree.c:    Dss_ObjForEachChild( pNtk->vObjs, pObj, pChild, k )
src/opt/dau/dauTree.c:    assert( p->nVars == pNtk->nVars );
src/opt/dau/dauTree.c:    if ( Dss_Regular(pNtk->pRoot)->Type == DAU_DSD_CONST0 )
src/opt/dau/dauTree.c:        return Dss_IsComplement(pNtk->pRoot);
src/opt/dau/dauTree.c:    if ( Dss_Regular(pNtk->pRoot)->Type == DAU_DSD_VAR )
src/opt/dau/dauTree.c:        return Abc_Var2Lit( Dss_Regular(pNtk->pRoot)->iVar + 1, Dss_IsComplement(pNtk->pRoot) );
src/opt/dau/dauTree.c:    return Dss_NtkRebuild_rec( p, pNtk, pNtk->pRoot );
src/opt/sfm/sfmDec.c:static inline Sfm_Dec_t * Sfm_DecMan( Abc_Obj_t * p )                        { return (Sfm_Dec_t *)p->pNtk->pData;                  }
src/opt/sfm/sfmDec.c:    pNtk->pData = p;
src/opt/sfm/sfmDec.c:    pNtk->pData = NULL;
src/opt/sfm/sfmDec.c:    Sfm_Dec_t * p = Sfm_DecStart( pPars, (Mio_Library_t *)pNtk->pManFunc, pNtk );
src/opt/sfm/sfmTim.c:    Mio_Library_t * pLib = (Mio_Library_t *)pNtk->pManFunc;
src/aig/gia/giaStr.c:            pNtk->nTrees++;
src/aig/gia/giaStr.c:        pNtk->nGroups++;
src/aig/gia/giaStr.c:    //assert( pNtk->nObjs <= Gia_ManObjNum(p) );
src/aig/gia/giaStr.c:    pNtk->DelayGain += Delay - Delay2;
src/aig/gia/giaStr.c:    pNtk->DelayGain += Delay - Delay2;
src/aig/gia/giaMinLut.c:    pNtk->pName = Extra_UtilStrsav( pMan->pName );
src/base/cmd/cmd.c:    if ( pNtk->pSpec )
src/base/cmd/cmd.c:        pNtkNew->pSpec = Extra_UtilStrsav( pNtk->pSpec );
src/base/cmd/cmd.c:    if ( pNtk->pSpec )
src/base/cmd/cmd.c:        pNtkNew->pSpec = Extra_UtilStrsav( pNtk->pSpec );
src/base/abci/abcIvy.c:    if ( pNtk->pExdc )
src/base/abci/abcIvy.c:        pNtkAig->pExdc = Abc_NtkDup( pNtk->pExdc );
src/base/abci/abcIvy.c:        pNtk->pModel = ABC_CALLOC( int, Abc_NtkCiNum(pNtk) );
src/base/abci/abcIvy.c:    pNtk->pModel = (int *)pMan2->pData, pMan2->pData = NULL;
src/base/abci/abcIvy.c://    pNtk->pModel = Aig_ManReleaseData( pMan2 );
src/base/abci/abcIvy.c:    pNtk->pModel = (int *)pMan->pData; pMan->pData = NULL;
src/base/abci/abcIvy.c:        pNtk->pModel = (int *)pMan2->pData, pMan2->pData = NULL;
src/base/abci/abcIvy.c:            RetValue = ( (Abc_NtkNodeNum(pNtk) == 1) && (Abc_ObjFanin0(Abc_NtkPo(pNtk,0))->pData == Cudd_ReadLogicZero((DdManager *)pNtk->pManFunc)) );
src/base/abci/abcIvy.c:    if ( pNtk->pExdc )
src/base/abci/abcIvy.c:        pNtkAig->pExdc = Abc_NtkDup( pNtk->pExdc );
src/base/abci/abcIvy.c:            pObjNew = Abc_AigXor( (Abc_Aig_t *)pNtk->pManFunc, pFaninNew0, pFaninNew1 );
src/base/abci/abcIvy.c:            pObjNew = Abc_AigAnd( (Abc_Aig_t *)pNtk->pManFunc, pFaninNew0, pFaninNew1 );
src/base/abci/abcIvy.c:            pObjNew = Abc_AigXor( (Abc_Aig_t *)pNtk->pManFunc, pFaninNew0, pFaninNew1 );
src/base/abci/abcIvy.c:            pObjNew = Abc_AigAnd( (Abc_Aig_t *)pNtk->pManFunc, pFaninNew0, pFaninNew1 );
src/base/abci/abcSpeedup.c:static inline float Abc_ObjArrival( Abc_Obj_t * pNode )                 { return pNode->pNtk->pLutTimes[3*pNode->Id+0]; }
src/base/abci/abcSpeedup.c:static inline float Abc_ObjRequired( Abc_Obj_t * pNode )                { return pNode->pNtk->pLutTimes[3*pNode->Id+1]; }
src/base/abci/abcSpeedup.c:static inline float Abc_ObjSlack( Abc_Obj_t * pNode )                   { return pNode->pNtk->pLutTimes[3*pNode->Id+2]; }
src/base/abci/abcSpeedup.c:static inline void  Abc_ObjSetArrival( Abc_Obj_t * pNode, float Time )  { pNode->pNtk->pLutTimes[3*pNode->Id+0] = Time; }
src/base/abci/abcSpeedup.c:static inline void  Abc_ObjSetRequired( Abc_Obj_t * pNode, float Time ) { pNode->pNtk->pLutTimes[3*pNode->Id+1] = Time; }
src/base/abci/abcSpeedup.c:static inline void  Abc_ObjSetSlack( Abc_Obj_t * pNode, float Time )    { pNode->pNtk->pLutTimes[3*pNode->Id+2] = Time; }
src/base/abci/abcSpeedup.c:    ABC_FREE( pNtk->pLutTimes );
src/base/abci/abcSpeedup.c:    pNtk->pLutTimes = ABC_ALLOC( float, 3 * Abc_NtkObjNumMax(pNtk) );
src/base/abci/abcSpeedup.c:        pNtk->pLutTimes[3*i+0] = pNtk->pLutTimes[3*i+2] = 0;
src/base/abci/abcSpeedup.c:        pNtk->pLutTimes[3*i+1] = ABC_INFINITY;
src/base/abci/abcUnreach.c:    if ( pNtk->pExdc )
src/base/abci/abcUnreach.c:        Abc_NtkDelete( pNtk->pExdc );
src/base/abci/abcUnreach.c:        pNtk->pExdc = NULL; 
src/base/abci/abcUnreach.c:    if ( pNtk->pExdc )
src/base/abci/abcUnreach.c:        Abc_NtkDelete( pNtk->pExdc );
src/base/abci/abcUnreach.c:    pNtk->pExdc = Abc_NtkConstructExdc( dd, pNtk, bUnreach );
src/base/abci/abcUnreach.c://    pNtk->pManGlob = NULL;
src/base/abci/abcUnreach.c:    if ( pNtk->pExdc && !Abc_NtkCheck( pNtk->pExdc ) )
src/base/abci/abcUnreach.c:        Abc_NtkDelete( pNtk->pExdc );
src/base/abci/abcUnreach.c://        bProd = Cudd_bddXnor( dd, bVar, pNtk->vFuncsGlob->pArray[i] );  Cudd_Ref( bProd );
src/base/abci/abcCascade.c:    pNtkNew->pName = Extra_UtilStrsav(pNtk->pName);
src/base/abci/abcResub.c:    Abc_AigCleanup((Abc_Aig_t *)pNtk->pManFunc);
src/base/abci/abcResub.c://    Abc_AigCheckFaninOrder( pNtk->pManFunc );
src/base/abci/abcExtract.c:            pObj  = Abc_AigAnd( (Abc_Aig_t *)p->pNtk->pManFunc, pObj0, pObj1 );
src/base/abci/abcExtract.c:            pObj  = Abc_AigXor( (Abc_Aig_t *)p->pNtk->pManFunc, pObj0, pObj1 );
src/base/abci/abcExtract.c:                pNew = Abc_AigAnd( (Abc_Aig_t *)p->pNtk->pManFunc, pNew, Abc_ObjFromLit(p->pNtk, iLit) );
src/base/abci/abcExtract.c:                pNew = Abc_AigXor( (Abc_Aig_t *)p->pNtk->pManFunc, pNew, Abc_ObjFromLit(p->pNtk, iLit) );
src/base/abci/abcSaucy.c:            pObj     = (Abc_Obj_t *)Vec_PtrEntry(s->pNtk->vPos, i);
src/base/abci/abcSaucy.c:            pObj     = (Abc_Obj_t *)Vec_PtrEntry(s->pNtk->vPis, i - numouts);
src/base/abci/abcSaucy.c:            pObj     = (Abc_Obj_t *)Vec_PtrEntry(s->pNtk->vPos, s->gamma[i]);
src/base/abci/abcSaucy.c:            pObj     = (Abc_Obj_t *)Vec_PtrEntry(s->pNtk->vPis, s->gamma[i] - numouts);
src/base/abci/abcSaucy.c:        pObj = (Abc_Obj_t *)Vec_PtrEntry(pNtk->vPos, v);
src/base/abci/abcSaucy.c:        pObj = (Abc_Obj_t *)Vec_PtrEntry(pNtk->vPis, v - numouts);       
src/base/abci/abcCollapse.c:    pNode->pData = Extra_bddRemapUp( (DdManager *)pNode->pNtk->pManFunc, bTemp = (DdNode *)pNode->pData );   Cudd_Ref( (DdNode *)pNode->pData );
src/base/abci/abcCollapse.c:    Cudd_RecursiveDeref( (DdManager *)pNode->pNtk->pManFunc, bTemp );
src/base/abci/abcCollapse.c:    if ( pNtk->pExdc )
src/base/abci/abcCollapse.c:        assert( Abc_NtkIsStrash(pNtk->pExdc) );
src/base/abci/abcCollapse.c:        assert( Abc_NtkCoNum(pNtk->pExdc) == 1 );
src/base/abci/abcCollapse.c:        if ( Abc_NtkBuildGlobalBdds(pNtk->pExdc, 10000000, 1, 1, 0, 0) == NULL )
src/base/abci/abcCollapse.c:        ddExdc = (DdManager *)Abc_NtkGlobalBddMan( pNtk->pExdc );
src/base/abci/abcCollapse.c:        bBddDc = (DdNode *)Abc_ObjGlobalBdd(Abc_NtkCo(pNtk->pExdc, 0));
src/base/abci/abcCollapse.c:        Abc_NtkFreeGlobalBdds( pNtk->pExdc, 1 );
src/base/abci/abcCollapse.c:    if ( pNtk->pExdc )
src/base/abci/abcCollapse.c:        pNtkNew->pExdc = Abc_NtkDup( pNtk->pExdc );
src/base/abci/abcCollapse.c:    pNew->pName = Abc_UtilStrsav( pNtk->pName );
src/base/abci/abcCollapse.c:    pNew->pSpec = Abc_UtilStrsav( pNtk->pSpec );
src/base/abci/abcCollapse.c:    if ( pNtk->pExdc )
src/base/abci/abcCollapse.c:        pNtkNew->pExdc = Abc_NtkDup( pNtk->pExdc );
src/base/abci/abcCollapse.c:    pNew->pName = Abc_UtilStrsav( pNtk->pName );
src/base/abci/abcCollapse.c:    pNew->pSpec = Abc_UtilStrsav( pNtk->pSpec );
src/base/abci/abcCollapse.c:    if ( pNtk->pExdc )
src/base/abci/abcCollapse.c:        pNtkNew->pExdc = Abc_NtkDup( pNtk->pExdc );
src/base/abci/abcExact.c:    pNtk->pName = Extra_UtilStrsav( "exact" );
src/base/abci/abcExact.c:    Vec_PtrPush( pNtk->vObjs, NULL );
src/base/abci/abcExact.c:        pObj->pData = Abc_SopRegister( (Mem_Flex_t*)pNtk->pManFunc, pSopCover );
src/base/abci/abcExact.c:        pObj->pData = Abc_SopRegister( (Mem_Flex_t*)pNtk->pManFunc, pSopCover );
src/base/abci/abcExact.c:    pNtk->pName = Extra_UtilStrsav( "exact" );
src/base/abci/abcExact.c:    Vec_PtrPush( pNtk->vObjs, NULL );
src/base/abci/abcFraig.c:    if ( fExdc && pNtk->pExdc == NULL )
src/base/abci/abcFraig.c:    if ( pNtk->pExdc )
src/base/abci/abcFraig.c:        pNtkNew->pExdc = Abc_NtkDup( pNtk->pExdc );
src/base/abci/abcFraig.c:    assert( pNtk->pExdc );
src/base/abci/abcFraig.c:    gNodeExdc = Abc_NtkToFraigExdc( pMan, pNtk, pNtk->pExdc );
src/base/abci/abcEspresso.c:    pNode->pData = Abc_SopFromEspresso( pNode->pNtk->pManFunc, Cover );
src/base/abci/abcNtbdd.c:    pNtk->pName = Extra_UtilStrsav(pNamePo);
src/base/abci/abcNtbdd.c:    Cudd_bddIthVar( (DdManager *)pNtk->pManFunc, Vec_PtrSize(vNamesPi) );
src/base/abci/abcNtbdd.c:    pNode->pData = (DdNode *)Cudd_bddTransfer( dd, (DdManager *)pNtk->pManFunc, (DdNode *)bFunc ); Cudd_Ref((DdNode *)pNode->pData);
src/base/abci/abcNtbdd.c:    DdManager * dd = (DdManager *)pNodeOld->pNtk->pManFunc;
src/base/abci/abcNtbdd.c:    Abc_AigCleanup( (Abc_Aig_t *)pNtk->pManFunc );
src/base/abci/abcNtbdd.c:    Vec_PtrWriteEntry( pNtk->vAttrs, VEC_ATTR_GLOBAL_BDD, pAttMan );
src/base/abci/abcSymm.c://      bFunc = pNtk->vFuncsGlob->pArray[i];
src/base/abci/abcDress.c:        pName = Nm_ManFindNameById( pNtk->pManName, pNode->Id );
src/base/abci/abcDress.c:        pName = Nm_ManFindNameById( pNet->pNtk->pManName, pNet->Id );
src/base/abci/abcTim.c:    pMan = (Hop_Man_t *)pNode->pNtk->pManFunc;
src/base/abci/abcBidec.c:        pObj->pData = Abc_NodeIfNodeResyn( p, (Hop_Man_t *)pNtk->pManFunc, (Hop_Obj_t *)pObj->pData, Abc_ObjFaninNum(pObj), vTruth, NULL, -1.0 );
src/base/abci/abcUnate.c://    dd       = pNtk->pManGlob;
src/base/abci/abcUnate.c://    pbGlobal = (DdNode **)Vec_PtrArray( pNtk->vFuncsGlob );
src/base/abci/abcUnate.c://    Extra_StopManager( pNtk->pManGlob );
src/base/abci/abcUnate.c://    pNtk->pManGlob = NULL;
src/base/abci/abcIf.c:    if ( (pPars->fDelayOpt || pPars->fDsdBalance || pPars->fUserRecLib || pPars->fUserSesLib) && pNtk->pManTime )
src/base/abci/abcIf.c:        if ( pNtk->AndGateDelay == 0.0 )
src/base/abci/abcIf.c:                pNtk->AndGateDelay = Mio_LibraryReadDelayAigNode((Mio_Library_t *)Abc_FrameReadLibGen());
src/base/abci/abcIf.c:            if ( pNtk->AndGateDelay == 0.0 )
src/base/abci/abcIf.c:                pNtk->AndGateDelay = 1.0;
src/base/abci/abcIf.c:            pPars->pTimesArr[c] /= pNtk->AndGateDelay;
src/base/abci/abcIf.c:            pPars->pTimesReq[c] /= pNtk->AndGateDelay;
src/base/abci/abcIf.c:    if ( pNtk->pExdc )
src/base/abci/abcIf.c:        pNtkNew->pExdc = Abc_NtkDup( pNtk->pExdc );
src/base/abci/abcMiter.c:    sprintf( Buffer, "%s_miter", pNtk->pName );
src/base/abci/abcMiter.c:    sprintf( Buffer, "%s_%d_frames", pNtk->pName, nFrames );
src/base/abci/abcMiter.c:    sprintf( Buffer, "%s_%d_frames", pNtk->pName, nFrames );
src/base/abci/abcMiter.c:            pMiter = Abc_AigAnd( (Abc_Aig_t *)pNtk->pManFunc, pMiter, Abc_ObjChild0(pNode) );
src/base/abci/abcMiter.c:            pMiter = Abc_AigXor( (Abc_Aig_t *)pNtk->pManFunc, pMiter, Abc_ObjChild0(pNode) );
src/base/abci/abcMiter.c:            pMiter = Abc_AigOr( (Abc_Aig_t *)pNtk->pManFunc, pMiter, Abc_ObjChild0(pNode) );
src/base/abci/abcMiter.c:    pNtkNew = Abc_NtkAlloc( pNtk->ntkType, pNtk->ntkFunc, 1 );
src/base/abci/abcMffc.c:    fprintf( pFile, ".model %s_part\n", pNodes[0]->pNtk->pName );
src/base/abci/abcMffc.c:    fprintf( pFile, ".model %s_part\n", pNtk->pName );
src/base/abci/abcRewrite.c:    Abc_AigCleanup((Abc_Aig_t *)pNtk->pManFunc);
src/base/abci/abcRewrite.c://        vAddedCells = Abc_AigUpdateStart( pNtk->pManFunc, &vUpdatedNets );
src/base/abci/abcRewrite.c:    pNtk->pManCut = pManCut;
src/base/abci/abcRewrite.c:            Abc_AigUpdateReset( (Abc_Aig_t *)pNtk->pManFunc );
src/base/abci/abcRewrite.c:    pNtk->pManCut = NULL;
src/base/abci/abcRewrite.c://        Abc_AigUpdateStop( pNtk->pManFunc );
src/base/abci/abcRewrite.c://    Abc_AigCheckFaninOrder( pNtk->pManFunc );
src/base/abci/abcFx.c:        pSop = pCube = Abc_SopStart( (Mem_Flex_t *)pNtk->pManFunc, Vec_IntEntry(vCount, i), Abc_ObjFaninNum(pNode) );
src/base/abci/abcMap.c://    Map_ManPrintStatsToFile( pNtk->pSpec, Map_ManReadAreaFinal(pMan), Map_ManReadRequiredGlo(pMan), Abc_Clock()-clk );
src/base/abci/abcMap.c:    if ( pNtk->pExdc )
src/base/abci/abcMap.c:        pNtkNew->pExdc = Abc_NtkDup( pNtk->pExdc );
src/base/abci/abcMap.c:    pMan = Map_ManCreate( Abc_NtkPiNum(pNtk) + Abc_NtkLatchNum(pNtk) - pNtk->nBarBufs, Abc_NtkPoNum(pNtk) + Abc_NtkLatchNum(pNtk) - pNtk->nBarBufs, fVerbose );
src/base/abci/abcMap.c:        if ( i == Abc_NtkCiNum(pNtk) - pNtk->nBarBufs )
src/base/abci/abcMap.c:    assert( Map_ManReadBufNum(pMan) == pNtk->nBarBufs );
src/base/abci/abcMap.c:        if ( i == Abc_NtkCoNum(pNtk) - pNtk->nBarBufs )
src/base/abci/abcMap.c:    assert( Map_ManReadBufNum(pMan) == pNtk->nBarBufs );
src/base/abci/abcMap.c:        if ( i >= Abc_NtkCiNum(pNtk) - pNtk->nBarBufs )
src/base/abci/abcMap.c:        if ( i < Abc_NtkCiNum(pNtk) - pNtk->nBarBufs )
src/base/abci/abcMap.c:        Map_NodeSetData( Map_ManReadBufs(pMan)[i - (Abc_NtkCiNum(pNtk) - pNtk->nBarBufs)], 1, (char *)pNode->pCopy );
src/base/abci/abcMap.c:        if ( i < Abc_NtkCoNum(pNtk) - pNtk->nBarBufs )
src/base/abci/abcMap.c:        pNodeMap = Map_ManReadBufDriver( pMan, i - (Abc_NtkCoNum(pNtk) - pNtk->nBarBufs) );
src/base/abci/abcMap.c:        if ( i >= Abc_NtkCoNum(pNtk) - pNtk->nBarBufs )
src/base/abci/abcMap.c:    pNtk->AndGateDelay = Delay;
src/base/abci/abcOrchestration.c:    Abc_AigCleanup((Abc_Aig_t *)pNtk->pManFunc);
src/base/abci/abcOrchestration.c:    pNtk->pManCut = pManCut;
src/base/abci/abcOrchestration.c:            Abc_AigUpdateReset( (Abc_Aig_t *)pNtk->pManFunc );
src/base/abci/abcOrchestration.c:    pNtk->pManCut = NULL;
src/base/abci/abcOrchestration.c:    Abc_AigCleanup((Abc_Aig_t *)pNtk->pManFunc);
src/base/abci/abcOrchestration.c:    Abc_AigCleanup((Abc_Aig_t *)pNtk->pManFunc);
src/base/abci/abcOrchestration.c://    Abc_AigCheckFaninOrder( pNtk->pManFunc );
src/base/abci/abcOrchestration.c:    Abc_AigCleanup((Abc_Aig_t *)pNtk->pManFunc);
src/base/abci/abcOrchestration.c:    pNtk->pManCut = pManCutRwr;
src/base/abci/abcOrchestration.c:            Abc_AigUpdateReset( (Abc_Aig_t *)pNtk->pManFunc );
src/base/abci/abcOrchestration.c:            Abc_AigUpdateReset( (Abc_Aig_t *)pNtk->pManFunc );
src/base/abci/abcOrchestration.c:            Abc_AigUpdateReset( (Abc_Aig_t *)pNtk->pManFunc );
src/base/abci/abcOrchestration.c:            Abc_AigUpdateReset( (Abc_Aig_t *)pNtk->pManFunc );
src/base/abci/abcOrchestration.c:            Abc_AigUpdateReset( (Abc_Aig_t *)pNtk->pManFunc );
src/base/abci/abcOrchestration.c:            Abc_AigUpdateReset( (Abc_Aig_t *)pNtk->pManFunc );
src/base/abci/abcOrchestration.c:    pNtk->pManCut = NULL;
src/base/abci/abcOrchestration.c:    Abc_AigCleanup((Abc_Aig_t *)pNtk->pManFunc);
src/base/abci/abcOrchestration.c:    pNtk->pManCut = pManCutRwr;
src/base/abci/abcOrchestration.c:                Abc_AigUpdateReset( (Abc_Aig_t *)pNtk->pManFunc );
src/base/abci/abcOrchestration.c:    pNtk->pManCut = NULL;
src/base/abci/abcOrchestration.c://    Abc_AigCheckFaninOrder( pNtk->pManFunc );
src/base/abci/abcOrchestration.c:    Abc_AigCleanup((Abc_Aig_t *)pNtk->pManFunc);
src/base/abci/abcOrchestration.c:    pNtk->pManCut = pManCutRwr;
src/base/abci/abcOrchestration.c:            Abc_AigUpdateReset( (Abc_Aig_t *)pNtk->pManFunc );
src/base/abci/abcOrchestration.c:            Abc_AigUpdateReset( (Abc_Aig_t *)pNtk->pManFunc );
src/base/abci/abcOrchestration.c:            Abc_AigUpdateReset( (Abc_Aig_t *)pNtk->pManFunc );
src/base/abci/abcOrchestration.c:            Abc_AigUpdateReset( (Abc_Aig_t *)pNtk->pManFunc );
src/base/abci/abcOrchestration.c:            Abc_AigUpdateReset( (Abc_Aig_t *)pNtk->pManFunc );
src/base/abci/abcOrchestration.c:            Abc_AigUpdateReset( (Abc_Aig_t *)pNtk->pManFunc );
src/base/abci/abcOrchestration.c:            Abc_AigUpdateReset( (Abc_Aig_t *)pNtk->pManFunc );
src/base/abci/abcOrchestration.c:    pNtk->pManCut = NULL;
src/base/abci/abcOrchestration.c://    Abc_AigCheckFaninOrder( pNtk->pManFunc );
src/base/abci/abcOrchestration.c:    Abc_AigCleanup((Abc_Aig_t *)pNtk->pManFunc);
src/base/abci/abcOrchestration.c:    pNtk->pManCut = pManCutRwr;
src/base/abci/abcOrchestration.c:            Abc_AigUpdateReset( (Abc_Aig_t *)pNtk->pManFunc );
src/base/abci/abcOrchestration.c:            Abc_AigUpdateReset( (Abc_Aig_t *)pNtk->pManFunc );
src/base/abci/abcOrchestration.c:    pNtk->pManCut = NULL;
src/base/abci/abcOrchestration.c://    Abc_AigCheckFaninOrder( pNtk->pManFunc );
src/base/abci/abcOrchestration.c:    Abc_AigCleanup((Abc_Aig_t *)pNtk->pManFunc);
src/base/abci/abcOrchestration.c:    pNtk->pManCut = pManCutRwr;
src/base/abci/abcOrchestration.c:            Abc_AigUpdateReset( (Abc_Aig_t *)pNtk->pManFunc );
src/base/abci/abcOrchestration.c:            Abc_AigUpdateReset( (Abc_Aig_t *)pNtk->pManFunc );
src/base/abci/abcOrchestration.c:    pNtk->pManCut = NULL;
src/base/abci/abcOrchestration.c://    Abc_AigCheckFaninOrder( pNtk->pManFunc );
src/base/abci/abcOrchestration.c:    Abc_AigCleanup((Abc_Aig_t *)pNtk->pManFunc);
src/base/abci/abcOrchestration.c:    pNtk->pManCut = pManCutRwr;
src/base/abci/abcOrchestration.c:    pNtk->pManCut = NULL;
src/base/abci/abcOrchestration.c://    Abc_AigCheckFaninOrder( pNtk->pManFunc );
src/base/abci/abcStrash.c:    if ( pNtk->pExdc )
src/base/abci/abcStrash.c:        pNtkAig->pExdc = Abc_NtkDup( pNtk->pExdc );
src/base/abci/abcStrash.c:    pObj->pCopy = Abc_AigAnd( (Abc_Aig_t *)pNtk->pManFunc, Abc_ObjChild0Copy(pObj), Abc_ObjChild1Copy(pObj) );
src/base/abci/abcStrash.c:    if ( pNtk->pExdc )
src/base/abci/abcStrash.c:        pNtkAig->pExdc = Abc_NtkDup( pNtk->pExdc );
src/base/abci/abcStrash.c:                Nm_ManDeleteIdName( pObj->pNtk->pManName, Abc_ObjFanout0(pObj)->Id );
src/base/abci/abcStrash.c:    if ( pNtk->pExdc )
src/base/abci/abcStrash.c:        pNtkAig->pExdc = Abc_NtkDup( pNtk->pExdc );
src/base/abci/abcStrash.c:    if ( pNtk->vNameIds )
src/base/abci/abcStrash.c:    if ( pNtk->vNameIds )
src/base/abci/abcStrash.c:    if ( pNtk->vNameIds )
src/base/abci/abcStrash.c:    if ( pNtk->pExdc )
src/base/abci/abcStrash.c:        pNtkAig->pExdc = Abc_NtkStrash( pNtk->pExdc, fAllNodes, fCleanup, fRecord );
src/base/abci/abcStrash.c:    pMan = (Hop_Man_t *)pNodeOld->pNtk->pManFunc;
src/base/abci/abcStrash.c:    pNtkNew->pName = Extra_UtilStrsav(pNtk->pName);
src/base/abci/abcStrash.c:    pNtkNew->pName = Extra_UtilStrsav(pNtk->pName);
src/base/abci/abcStrash.c:    pNtkAig->pName = Extra_UtilStrsav(pNtk->pName);
src/base/abci/abcStrash.c:    pNtkAig->pSpec = Extra_UtilStrsav(pNtk->pSpec);
src/base/abci/abcStrash.c:    pNtkNew = Abc_NtkAlloc( pNtk->ntkType, pNtk->ntkFunc, 1 );
src/base/abci/abcStrash.c:    pNtkNew->pName = Extra_UtilStrsav(pNtk->pName);
src/base/abci/abcStrash.c:    pNtkNew->pSpec = Extra_UtilStrsav(pNtk->pSpec);
src/base/abci/abcQuant.c:            pObj->pCopy = Abc_AigAnd( (Abc_Aig_t *)pNtk->pManFunc, Abc_ObjChild0Copy(pObj), Abc_ObjChild1Copy(pObj) );
src/base/abci/abcQuant.c:            pObj->pData = Abc_AigAnd( (Abc_Aig_t *)pNtk->pManFunc, Abc_ObjChild0Data(pObj), Abc_ObjChild1Data(pObj) );
src/base/abci/abcQuant.c:            pNext = Abc_AigAnd( (Abc_Aig_t *)pNtk->pManFunc, Abc_ObjChild0Copy(pObj), Abc_ObjChild0Data(pObj) );
src/base/abci/abcQuant.c:            pNext = Abc_AigOr( (Abc_Aig_t *)pNtk->pManFunc, Abc_ObjChild0Copy(pObj), Abc_ObjChild0Data(pObj) );
src/base/abci/abcQuant.c://            Abc_AigDeleteNode( pNtk->pManFunc, pFanin );
src/base/abci/abcQuant.c:    sprintf( Buffer, "%s_TR", pNtk->pName );
src/base/abci/abcQuant.c:    pNtkNew->pName = Extra_UtilStrsav(pNtk->pName);
src/base/abci/abcQuant.c://    pNtkNew->pSpec = Extra_UtilStrsav(pNtk->pSpec);
src/base/abci/abcDsd.c:    if ( pNtk->pExdc )
src/base/abci/abcDsd.c:        pNtkNew->pExdc = Abc_NtkDup( pNtk->pExdc );
src/base/abci/abcDsd.c:    DdManager * dd = (DdManager *)pNtk->pManFunc;
src/base/abci/abcDsd.c:    DdManager * dd = (DdManager *)pNode->pNtk->pManFunc;
src/base/abci/abcDsd.c://    DdManager * dd = pNode->pNtk->pManFunc;
src/base/abci/abcDsd.c:    pNtkNew->pName = Extra_UtilStrsav(pNtk->pName);
src/base/abci/abcDsd.c:    pNtkNew->pSpec = Extra_UtilStrsav(pNtk->pSpec);
src/base/abci/abcDress3.c:    pHopMan = (Hop_Man_t *)pNtk->pManFunc;
src/base/abci/abcAuto.c://    dd       = pNtk->pManGlob;
src/base/abci/abcAuto.c://    Extra_StopManager( pNtk->pManGlob );
src/base/abci/abcAuto.c://    pNtk->pManGlob = NULL;
src/base/abci/abcBalance.c:    if ( pNtk->pExdc )
src/base/abci/abcBalance.c:        pNtkAig->pExdc = Abc_NtkDup( pNtk->pExdc );
src/base/abci/abcBalance.c:    if ( pNtk->nBarBufs == 0 )
src/base/abci/abcBalance.c:            if ( i < pNtk->nBarBufs )
src/base/abci/abcLutmin.c:    DdManager * ddOld = (DdManager *)pNode->pNtk->pManFunc;
src/base/abci/abcLutmin.c:    DdManager * ddOld = (DdManager *)pNode->pNtk->pManFunc;
src/base/abci/abcLutmin.c:    DdManager * dd = (DdManager *)pNode->pNtk->pManFunc;
src/base/abci/abcDar.c:        if ( pNtk->nConstrs && i >= pNtk->nConstrs )
src/base/abci/abcDar.c:    pMan->nConstrs = pNtk->nConstrs;
src/base/abci/abcDar.c:    pMan->nBarBufs = pNtk->nBarBufs;
src/base/abci/abcDar.c:    pMan->pName = Extra_UtilStrsav( pNtk->pName );
src/base/abci/abcDar.c:    pMan->pSpec = Extra_UtilStrsav( pNtk->pSpec );
src/base/abci/abcDar.c:    pMan->nConstrs = pNtk->nConstrs;
src/base/abci/abcDar.c:    pMan->nBarBufs = pNtk->nBarBufs;
src/base/abci/abcDar.c:    pMan->pName = Extra_UtilStrsav( pNtk->pName );
src/base/abci/abcDar.c:    pMan->pSpec = Extra_UtilStrsav( pNtk->pSpec );
src/base/abci/abcDar.c:        if ( pNtk->vOnehots )
src/base/abci/abcDar.c:            pMan->vOnehots = (Vec_Ptr_t *)Vec_VecDupInt( (Vec_Vec_t *)pNtk->vOnehots );
src/base/abci/abcDar.c:    pMan->nConstrs = pNtk->nConstrs;
src/base/abci/abcDar.c:    pMan->nBarBufs = pNtk->nBarBufs;
src/base/abci/abcDar.c:    pMan->pName = Extra_UtilStrsav( pNtk->pName );
src/base/abci/abcDar.c:    pMan->pSpec = Extra_UtilStrsav( pNtk->pSpec );
src/base/abci/abcDar.c:    //pNtk->pName      = Extra_UtilStrsav(pGia->pName);
src/base/abci/abcDar.c:    pNtk->pModel = (int *)pMan->pData, pMan->pData = NULL;
src/base/abci/abcDar.c:    pNtk->pModel = (int *)pMan->pData, pMan->pData = NULL;
src/base/abci/abcDar.c:        ABC_FREE( pNtk->pModel );
src/base/abci/abcDar.c:        ABC_FREE( pNtk->pSeqModel );
src/base/abci/abcDar.c:        pNtk->pSeqModel = pMan->pSeqModel; pMan->pSeqModel = NULL;
src/base/abci/abcDar.c:            Abc_Cex_t * pCex = pNtk->pSeqModel;
src/base/abci/abcDar.c:            Abc_Print( 1, "Output %d of miter \"%s\" was asserted in frame %d. ", pCex->iPo, pNtk->pName, pCex->iFrame );
src/base/abci/abcDar.c:        ABC_FREE( pNtk->pModel );
src/base/abci/abcDar.c:        ABC_FREE( pNtk->pSeqModel );
src/base/abci/abcDar.c:        pNtk->pSeqModel = pMan->pSeqModel; pMan->pSeqModel = NULL;
src/base/abci/abcDar.c:    if ( pNtk->pSeqModel ) 
src/base/abci/abcDar.c:        status = Saig_ManVerifyCex( pMan, pNtk->pSeqModel );
src/base/abci/abcDar.c:    if ( pNtk->pSeqModel && vMap )
src/base/abci/abcDar.c:        pNtk->pSeqModel->iPo = Vec_IntEntry( vMap, pNtk->pSeqModel->iPo );
src/base/abci/abcDar.c:    ABC_FREE( pNtk->pModel );
src/base/abci/abcDar.c:    ABC_FREE( pNtk->pSeqModel );
src/base/abci/abcDar.c:    pNtk->pSeqModel = pMan->pSeqModel; pMan->pSeqModel = NULL;
src/base/abci/abcDar.c:                Abc_Cex_t * pCex = pNtk->pSeqModel;
src/base/abci/abcDar.c:                Abc_Print( 1, "Output %d of miter \"%s\" was asserted in frame %d. ", pCex->iPo, pNtk->pName, pCex->iFrame );
src/base/abci/abcDar.c:        if ( pNtk->vSeqModelVec )
src/base/abci/abcDar.c:            Vec_PtrFreeFree( pNtk->vSeqModelVec );
src/base/abci/abcDar.c:        pNtk->vSeqModelVec = pMan->vSeqModelVec;  pMan->vSeqModelVec = NULL;
src/base/abci/abcDar.c:    if ( pNtk->pSeqModel ) 
src/base/abci/abcDar.c:        status = Saig_ManVerifyCex( pMan, pNtk->pSeqModel );
src/base/abci/abcDar.c:    if ( pNtk->pSeqModel && vMap )
src/base/abci/abcDar.c:        pNtk->pSeqModel->iPo = Vec_IntEntry( vMap, pNtk->pSeqModel->iPo );
src/base/abci/abcDar.c://                pNtk->pModel = pTemp->pData, pTemp->pData = NULL;
src/base/abci/abcDar.c:    ABC_FREE( pNtk->pModel );
src/base/abci/abcDar.c:    ABC_FREE( pNtk->pSeqModel );
src/base/abci/abcDar.c:    pNtk->pSeqModel = pMan->pSeqModel; pMan->pSeqModel = NULL;
src/base/abci/abcDar.c:    pFileNameGeneric = Extra_FileNameGeneric( pNtk->pSpec ? pNtk->pSpec : pNtk->pName );
src/base/abci/abcDar.c:    pFileNameGeneric = Extra_FileNameGeneric( pNtk->pSpec );
src/base/abci/abcDar.c:    pFileNameGeneric = Extra_FileNameGeneric( pNtk->pSpec );
src/base/abci/abcDar.c://        pNtk->pModel = pNtkComb->pModel; pNtkComb->pModel = NULL;
src/base/abci/abcDar.c:            pNtk->pModel = pNtkComb->pModel; pNtkComb->pModel = NULL;
src/base/abci/abcDar.c:            ABC_FREE( pNtk->pModel );
src/base/abci/abcDar.c:            ABC_FREE( pNtk->pSeqModel );
src/base/abci/abcDar.c:            pNtk->pSeqModel = pMan->pSeqModel; pMan->pSeqModel = NULL;
src/base/abci/abcDar.c:        ABC_FREE( pNtk->pModel );
src/base/abci/abcDar.c:        ABC_FREE( pNtk->pSeqModel );
src/base/abci/abcDar.c:        pNtk->pSeqModel = pMan->pSeqModel; pMan->pSeqModel = NULL;
src/base/abci/abcDar.c:        if ( pNtk->pSeqModel )
src/base/abci/abcDar.c:            Abc_Cex_t * pCex = pNtk->pSeqModel;
src/base/abci/abcDar.c:            Abc_Print( 1, "Output %d of miter \"%s\" was asserted in frame %d.\n", pCex->iPo, pNtk->pName, pCex->iFrame );
src/base/abci/abcDar.c:            if ( !Saig_ManVerifyCex( pMan, pNtk->pSeqModel ) )
src/base/abci/abcDar.c:                    Abc_Print( 1, "Output %d of miter \"%s\" was asserted in frame %d.  ", pMan->pSeqModel->iPo, pNtk->pName, pMan->pSeqModel->iFrame );
src/base/abci/abcDar.c:    ABC_FREE( pNtk->pSeqModel );
src/base/abci/abcDar.c:    pNtk->pSeqModel = pMan->pSeqModel;
src/base/abci/abcDar.c:    if ( pNtk->vSeqModelVec )
src/base/abci/abcDar.c:        Vec_PtrFreeFree( pNtk->vSeqModelVec );
src/base/abci/abcDar.c:    pNtk->vSeqModelVec = pMan->vSeqModelVec;
src/base/abci/abcDar.c:        Abc_AigCleanup((Abc_Aig_t *)pNtk->pManFunc);
src/base/abci/abcDar.c:            ABC_FREE( pNtk->pModel );
src/base/abci/abcDar.c:            ABC_FREE( pNtk->pSeqModel );
src/base/abci/abcDar.c:            pNtk->pSeqModel = pGia->pCexSeq; pGia->pCexSeq = NULL;
src/base/abci/abcDar.c:            ABC_FREE( pNtk->pModel );
src/base/abci/abcDar.c:            ABC_FREE( pNtk->pSeqModel );
src/base/abci/abcDar.c:            pNtk->pSeqModel = pCex;
src/base/abci/abcDar.c:        Abc_AigCleanup((Abc_Aig_t *)pNtk->pManFunc);
src/base/abci/abcDar.c:        ABC_FREE( pNtk->pModel );
src/base/abci/abcDar.c:        ABC_FREE( pNtk->pSeqModel );
src/base/abci/abcDar.c:        pNtk->pSeqModel = pMan->pSeqModel; pMan->pSeqModel = NULL;
src/base/abci/abcDar.c:    if ( pNtk->vSeqModelVec )
src/base/abci/abcDar.c:        Vec_PtrFreeFree( pNtk->vSeqModelVec );
src/base/abci/abcDar.c:    pNtk->vSeqModelVec = pMan->vSeqModelVec;  pMan->vSeqModelVec = NULL;
src/base/abci/abcDar.c:    pNtk->pData = pMan->pData; pMan->pData = NULL;
src/base/abci/abcDar.c:        ABC_FREE( pNtk->pModel );
src/base/abci/abcDar.c:        ABC_FREE( pNtk->pSeqModel );
src/base/abci/abcDar.c:        pNtk->pSeqModel = pMan->pSeqModel; pMan->pSeqModel = NULL;
src/base/abci/abcDar.c://    pNtkAig->pName = Extra_UtilStrsav(pNtk->pName);
src/base/abci/abcDar.c://    pNtkAig->pSpec = Extra_UtilStrsav(pNtk->pSpec);
src/base/abci/abcDar.c:    pNtkAig->pName = Extra_UtilStrsav(pNtk->pName);
src/base/abci/abcDar.c:    pNtkAig->pSpec = Extra_UtilStrsav(pNtk->pSpec);
src/base/abci/abcDar.c:    pNtkAig->pName = Extra_UtilStrsav(pNtk->pName);
src/base/abci/abcDar.c:    pNtkAig->pSpec = Extra_UtilStrsav(pNtk->pSpec);
src/base/abci/abcDar.c:    pNtkAig->pName = Extra_UtilStrsav(pNtk->pName);
src/base/abci/abcDar.c:    pNtkAig->pSpec = Extra_UtilStrsav(pNtk->pSpec);
src/base/abci/abcDar.c:    ABC_FREE( pNtk->pModel );
src/base/abci/abcDar.c:    ABC_FREE( pNtk->pSeqModel );
src/base/abci/abcDar.c:    pNtk->pSeqModel = pMan->pSeqModel; pMan->pSeqModel = NULL;
src/base/abci/abcDar.c:    pNtkAig->pName = Extra_UtilStrsav(pNtk->pName);
src/base/abci/abcDar.c:    pNtkAig->pSpec = Extra_UtilStrsav(pNtk->pSpec);
src/base/abci/abcDar.c:    pNtkAig->pName = Extra_UtilStrsav(pNtk->pName);
src/base/abci/abcDar.c:    pNtkAig->pSpec = Extra_UtilStrsav(pNtk->pSpec);
src/base/abci/abcPrint.c:          strcmp(ParsBest.pName, pNtk->pName) ||
src/base/abci/abcPrint.c:        ParsBest.pName = Extra_UtilStrsav( pNtk->pName );
src/base/abci/abcPrint.c:        if ( strcmp(pNtk->pSpec + strlen(pNtk->pSpec) - strlen("_best.blif"), "_best.blif") )
src/base/abci/abcPrint.c:            pFileNameOut = Extra_FileNameGenericAppend( pNtk->pSpec, "_best.blif" );
src/base/abci/abcPrint.c:            pFileNameOut = pNtk->pSpec;
src/base/abci/abcPrint.c:        const char * pNameGen = pNtk->pSpec? Extra_FileNameGeneric( pNtk->pSpec ) : "nameless_";
src/base/abci/abcPrint.c:        if ( pNtk->pSpec ) ABC_FREE( pNameGen );
src/base/abci/abcPrint.c://        Abc_AigCountNext( pNtk->pManFunc );
src/base/abci/abcPrint.c:    Abc_Print( 1,"%-30s:", pNtk->pName );
src/base/abci/abcPrint.c:    Abc_Print( 1,"%s%-30s:%s", "\033[1;37m", pNtk->pName, "\033[0m" );  // bright
src/base/abci/abcPrint.c:    if ( pNtk->nBarBufs )
src/base/abci/abcPrint.c:        Abc_Print( 1,"(b=%d)", pNtk->nBarBufs );
src/base/abci/abcPrint.c:        int fHasTimeMan = (int)(pNtk->pManTime != NULL);
src/base/abci/abcPrint.c:        assert( pNtk->pManFunc == Abc_FrameReadLibGen() );
src/base/abci/abcPrint.c:        if ( !fHasTimeMan && pNtk->pManTime )
src/base/abci/abcPrint.c:            Abc_ManTimeStop( pNtk->pManTime );
src/base/abci/abcPrint.c:            pNtk->pManTime = NULL;
src/base/abci/abcPrint.c:    if ( pNtk->nBarBufs2 )
src/base/abci/abcPrint.c:        Abc_Print( 1,"  buf = %d", pNtk->nBarBufs2 );
src/base/abci/abcPrint.c:        fprintf( pTable, "%s ",  pNtk->pName );
src/base/abci/abcPrint.c://        fprintf( pTable, "%s ",  pNtk->pName );
src/base/abci/abcPrint.c://        fprintf( pTable, "%s ",  pNtk->pSpec );
src/base/abci/abcPrint.c:        fprintf( pTable, "%s ",  pNtk->pName );
src/base/abci/abcPrint.c:        fprintf( pTable, "%s ", pNtk->pName );
src/base/abci/abcPrint.c:        fprintf( pTable, "%s ", pNtk->pName );
src/base/abci/abcPrint.c:    if ( pNtk->pExdc )
src/base/abci/abcPrint.c:        Abc_NtkPrintStats( pNtk->pExdc, fFactored, fSaveBest, fDumpResult, fUseLutLib, fPrintMuxes, fPower, fGlitch, fSkipBuf, fSkipSmall, fPrintMem );
src/base/abci/abcPrint.c://    fprintf( pFile, "%-15s:  ", pNtk->pName );
src/base/abci/abcPrint.c:        Extra_PrintKMap( stdout, (DdManager *)pNode->pNtk->pManFunc, (DdNode *)pNode->pData, Cudd_Not(pNode->pData),
src/base/abci/abcPrint.c:        Extra_PrintKMap( stdout, (DdManager *)pNode->pNtk->pManFunc, (DdNode *)pNode->pData, Cudd_Not(pNode->pData),
src/base/abci/abcPrint.c:        nGates = Mio_LibraryReadGateNum( (Mio_Library_t *)pNtk->pManFunc );
src/base/abci/abcPrint.c:        ppGates = Mio_LibraryReadGateArray( (Mio_Library_t *)pNtk->pManFunc );
src/base/abci/abcPrint.c:        puTruth = Hop_ManConvertAigToTruth( (Hop_Man_t *)pNtk->pManFunc, (Hop_Obj_t *)pObj->pData, Abc_ObjFaninNum(pObj), vTruth, 0 );
src/base/abci/abcSense.c:    pMiter->pName = Extra_UtilStrsav(pNtk->pName);
src/base/abci/abcSense.c:    pMiter->pSpec = Extra_UtilStrsav(pNtk->pSpec);
src/base/abci/abcBm.c:        pNtk->pModel = Sat_SolverGetModel( pSat, vCiIds->pArray, vCiIds->nSize );
src/base/abci/abcSweep.c:        Hop_ManStop( (Hop_Man_t *)pNtk->pManFunc );
src/base/abci/abcSweep.c:        pNtk->pManFunc = Abc_FrameReadLibGen();
src/base/abci/abcSweep.c:        pNtk->ntkFunc = ABC_FUNC_MAP;
src/base/abci/abcSweep.c:        if ( pNtk->pExdc == NULL )
src/base/abci/abcSweep.c:    assert( pNtk->pExdc );
src/base/abci/abcSweep.c:    gNodeExdc = Abc_NtkToFraigExdc( pMan, pNtk, pNtk->pExdc );
src/base/abci/abcSweep.c:        printf( "Sweeping stats for network \"%s\":\n", pNtk->pName );
src/base/abci/abcSweep.c:    DdManager * dd = (DdManager *)pNode->pNtk->pManFunc;
src/base/abci/abcSweep.c:    pMan = (Hop_Man_t *)pNtk->pManFunc;
src/base/abci/abcRestruct.c:    Abc_AigCleanup((Abc_Aig_t *)pNtk->pManFunc);
src/base/abci/abcRestruct.c://    pNtk->pManCut = pManCut;
src/base/abci/abcRestruct.c://    Abc_AigCheckFaninOrder( pNtk->pManFunc );
src/base/abci/abcRestruct.c:                pTemp = Abc_AigXorLookup( (Abc_Aig_t *)pManRst->pNtk->pManFunc, pNode1, pNode3, NULL );
src/base/abci/abcRestruct.c:                pTemp = Abc_AigAndLookup( (Abc_Aig_t *)pManRst->pNtk->pManFunc, Abc_ObjNot(pNode1), Abc_ObjNot(pNode3) );
src/base/abci/abcRestruct.c:                pNode3 = Abc_AigAndLookup( (Abc_Aig_t *)pManRst->pNtk->pManFunc, Abc_ObjNot(pNode1), Abc_ObjNot(pNode2) ); 
src/base/abci/abcRestruct.c:                pNode3 = Abc_AigXorLookup( (Abc_Aig_t *)pManRst->pNtk->pManFunc, pNode1, pNode2, &Type ); 
src/base/abci/abcRestruct.c:                    pTemp = Abc_AigAndLookup( (Abc_Aig_t *)pManRst->pNtk->pManFunc, pNode1, Abc_ObjNot(pNode2) );
src/base/abci/abcRestruct.c:                    pTemp = Abc_AigAndLookup( (Abc_Aig_t *)pManRst->pNtk->pManFunc, Abc_ObjNot(pNode1), pNode2 );
src/base/abci/abcRestruct.c:                    pTemp = Abc_AigAndLookup( (Abc_Aig_t *)pManRst->pNtk->pManFunc, Abc_ObjNot(pNode1), Abc_ObjNot(pNode2) );
src/base/abci/abcRestruct.c:                    pTemp = Abc_AigAndLookup( (Abc_Aig_t *)pManRst->pNtk->pManFunc, pNode1, pNode2 );
src/base/abci/abcRestruct.c:            pNode4 = Abc_AigMuxLookup( (Abc_Aig_t *)pManRst->pNtk->pManFunc, pNode1, pNode2, pNode3, &Type ); 
src/base/abci/abcRestruct.c:                    pTemp = Abc_AigAndLookup( (Abc_Aig_t *)pManRst->pNtk->pManFunc, pNode1, pNode2 );
src/base/abci/abcRestruct.c:                    pTemp = Abc_AigAndLookup( (Abc_Aig_t *)pManRst->pNtk->pManFunc, Abc_ObjNot(pNode1), pNode3 );
src/base/abci/abcRestruct.c:                    pTemp = Abc_AigAndLookup( (Abc_Aig_t *)pManRst->pNtk->pManFunc, pNode1, Abc_ObjNot(pNode2) );
src/base/abci/abcRestruct.c:                    pTemp = Abc_AigAndLookup( (Abc_Aig_t *)pManRst->pNtk->pManFunc, Abc_ObjNot(pNode1), Abc_ObjNot(pNode3) );
src/base/abci/abcMfs.c:        pNode->pData = Abc_SopCreateFromTruthIsop( (Mem_Flex_t *)pNtk->pManFunc, Vec_IntSize(vArray), pTruth, vCover );
src/base/abci/abcMfs.c:    pNtk->pName = Extra_UtilStrsav(Abc_NtkName(p));
src/base/abci/abcCas.c:    pFileGeneric = Extra_FileNameGeneric( pNtk->pSpec );
src/base/abci/abcCas.c://    if ( pNtk->pExdc )
src/base/abci/abcCas.c://        pNtkNew->pExdc = Abc_NtkDup( pNtk->pExdc );
src/base/abci/abcRefactor.c:    Abc_AigCleanup((Abc_Aig_t *)pNtk->pManFunc);
src/base/abci/abcRefactor.c://    Abc_AigCheckFaninOrder( pNtk->pManFunc );
src/base/abci/abcOrder.c:            Vec_PtrWriteEntry( pNtk->vCis, Vec_PtrSize(vSupp)-1-i, pObj );
src/base/abci/abcOrder.c:            Vec_PtrWriteEntry( pNtk->vCis, i, pObj );
src/base/abci/abcOrder.c:    Vec_PtrClear( pNtk->vPis );
src/base/abci/abcOrder.c:            Vec_PtrPush( pNtk->vPis, pObj );
src/base/abci/abcQbf.c:        pFileName = Extra_FileNameGenericAppend( pNtk->pSpec, ".qdimacs" );
src/base/abci/abcQbf.c:    pModel = pNtk->pModel;
src/base/abci/abcAttach.c:    pNtk->ntkFunc = ABC_FUNC_MAP;
src/base/abci/abcAttach.c:    Extra_MmFlexStop( (Extra_MmFlex_t *)pNtk->pManFunc );
src/base/abci/abcAttach.c:    pNtk->pManFunc = pGenlib;
src/base/abci/abcLut.c:    pObjNew->pData = Abc_SopCreateFromTruth( (Mem_Flex_t *)pObj->pNtk->pManFunc, Vec_PtrSize(p->vLeaves), p->uTruth ); // need ISOP
src/base/abci/abcLut.c:        pObjNew->pData = Abc_SopCreateFromTruth( (Mem_Flex_t *)pNtk->pManFunc, p->nLutSize, pTruth ); // need ISOP
src/base/abci/abcReorder.c:    bFunc = Extra_Reorder( p, (DdManager *)pNode->pNtk->pManFunc, (DdNode *)pNode->pData, pOrder ); Cudd_Ref( bFunc );
src/base/abci/abcReorder.c:    Cudd_RecursiveDeref( (DdManager *)pNode->pNtk->pManFunc, (DdNode *)pNode->pData );
src/base/abci/abcRr.c:        return Abc_AigReplace( (Abc_Aig_t *)pNtk->pManFunc, pNode, pNodeNew, 1 );
src/base/abci/abcRr.c:        pFanoutNew = Abc_AigAnd( (Abc_Aig_t *)pNtk->pManFunc, Abc_ObjNotCond(pNodeNew,Abc_ObjFaninC0(pFanout)), Abc_ObjChild1(pFanout) );
src/base/abci/abcRr.c:        pFanoutNew = Abc_AigAnd( (Abc_Aig_t *)pNtk->pManFunc, Abc_ObjNotCond(pNodeNew,Abc_ObjFaninC1(pFanout)), Abc_ObjChild0(pFanout) );
src/base/abci/abcRr.c:    Abc_AigReplace( (Abc_Aig_t *)pNtk->pManFunc, pFanout, pFanoutNew, 1 );
src/base/abci/abcRr.c:    pNtkNew = Abc_NtkAlloc( pNtk->ntkType, pNtk->ntkFunc, 1 );
src/base/abci/abcSat.c:        pNtk->pModel = Sat_SolverGetModel( pSat, vCiIds->pArray, vCiIds->nSize );
src/base/abci/abcSat.c:    pNtk->pName = Extra_UtilStrsav(p->pName);
src/base/abci/abcSat.c:        pResult = pNtk->pModel, pNtk->pModel = NULL;
src/base/abci/abcSat.c:    if ( Cudd_Regular((Abc_Obj_t *)pNode->pData) == Cudd_ReadOne((DdManager *)pNode->pNtk->pManFunc) )
src/base/abci/abcCut.c://    Cut_ManPrintStatsToFile( p, pNtk->pSpec, Abc_Clock() - clk );
src/base/abci/abcFpga.c:    if ( pNtk->pExdc )
src/base/abci/abcFpga.c:        pNtkNew->pExdc = Abc_NtkDup( pNtk->pExdc );
src/base/abci/abcMini.c:    pNtk->pName = Abc_UtilStrsav( "MiniAig" );
src/base/abci/abcMini.c:            pObj = Abc_AigAnd((Abc_Aig_t *)pNtk->pManFunc, Abc_NodeFanin0Copy(pNtk, vCopies, p, i), Abc_NodeFanin1Copy(pNtk, vCopies, p, i));
src/base/abci/abcMini.c:    Abc_AigCleanup( (Abc_Aig_t *)pNtk->pManFunc );
src/base/abci/abcDetect.c:    Mio_Library_t * pLib = (Mio_Library_t *)pNtk->pManFunc;
src/base/abci/abcDetect.c:    Mio_Library_t * pLib = (Mio_Library_t *)pNtk->pManFunc;
src/base/abci/abcDetect.c:    if ( pNtk->nConstrs == 0 )
src/base/abci/abcDetect.c:    assert( Abc_NtkPiNum(pNtk) >= pNtk->nConstrs );
src/base/abci/abcDetect.c:    assert( Abc_NtkPoNum(pNtk) >= pNtk->nConstrs * 4 );
src/base/abci/abcDetect.c:        if ( i < nPisOld - pNtk->nConstrs )
src/base/abci/abcDetect.c:        if ( i < nPosOld - 4 * pNtk->nConstrs )
src/base/abci/abcDetect.c:        Mio_Library_t * pLib = (Mio_Library_t *)pObj->pNtk->pManFunc;
src/base/abci/abcDetect.c:        Mio_Library_t * pLib = (Mio_Library_t *)pObj->pNtk->pManFunc;
src/base/abci/abcDetect.c:    pNew->pName = Abc_UtilStrsav( pNtk->pName );
src/base/abci/abcDetect.c:    pNew->pSpec = Abc_UtilStrsav( pNtk->pSpec );
src/base/abci/abcDetect.c:    Mio_Library_t * pLib = (Mio_Library_t *)pNtk->pManFunc;
src/base/abci/abcDetect.c:    Vec_IntForEachEntryDoubleStart( pNtk->vFins, iObj, Type, i, 2 )
src/base/abci/abcDetect.c:    if ( pNtk->vFins == NULL )
src/base/abci/abcDetect.c:    vPairs   = pNtk->vFins;
src/base/abci/abcFxu.c:    p->pManSop    = (Mem_Flex_t *)pNtk->pManFunc;
src/base/abci/abc.c:    if ( pNtk->pExdc == NULL )
src/base/abci/abc.c:        if ( !Abc_NtkIsStrash(pNtk->pExdc) )
src/base/abci/abc.c:            pNtkTemp = Abc_NtkStrash(pNtk->pExdc, 0, 0, 0);
src/base/abci/abc.c:            Percentage = Abc_NtkSpacePercentage( Abc_ObjChild0( Abc_NtkPo(pNtk->pExdc, 0) ) );
src/base/abci/abc.c:    Abc_NtkPrintStats( pNtk->pExdc, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 );
src/base/abci/abc.c:            Cudd_CountMinterm((DdManager *)pNtk->pManFunc, (DdNode *)pObj->pData, Abc_ObjFaninNum(pObj)) );
src/base/abci/abc.c:        pTruth = Hop_ManConvertAigToTruth( (Hop_Man_t *)pNtk->pManFunc, Hop_Regular((Hop_Obj_t *)pObj->pData), Abc_ObjFaninNum(pObj), vMemory, 0 );
src/base/abci/abc.c:        int Num = Nm_ManFindIdByName( pNtk->pManName, argv[globalUtilOptind], ABC_OBJ_PO );
src/base/abci/abc.c:            Num = Nm_ManFindIdByName( pNtk->pManName, argv[globalUtilOptind], ABC_OBJ_BI );
src/base/abci/abc.c:        int Num = Nm_ManFindIdByName( pNtk->pManName, argv[globalUtilOptind+1], ABC_OBJ_PI );
src/base/abci/abc.c:            Num = Nm_ManFindIdByName( pNtk->pManName, argv[globalUtilOptind+1], ABC_OBJ_BO );
src/base/abci/abc.c:        pNtkRes->pName = Extra_UtilStrsav(pNtk->pName);
src/base/abci/abc.c:    Abc_AigCleanup( (Abc_Aig_t *)pNtk->pManFunc );
src/base/abci/abc.c:    Abc_FrameReplaceCex( pAbc, &pNtk->pSeqModel );
src/base/abci/abc.c://    pNtkRes = Abc_NtkDeriveFromBdd( pNtk->pManFunc, pNode->pData, NULL, NULL );
src/base/abci/abc.c:    pNtkRes->pName = Extra_UtilStrsav(pNtk->pName);
src/base/abci/abc.c:    pNtkRes->pSpec = Extra_UtilStrsav(pNtk->pSpec);
src/base/abci/abc.c:    if ( pNtk->pExdc == NULL )
src/base/abci/abc.c:    Abc_NtkDelete( pNtk->pExdc );
src/base/abci/abc.c:    pNtk->pExdc = NULL;
src/base/abci/abc.c:    if ( pNtk->pExdc == NULL )
src/base/abci/abc.c:    pNtkRes = Abc_NtkDup( pNtk->pExdc );
src/base/abci/abc.c:    if ( pNtk->pExdc )
src/base/abci/abc.c:        Abc_NtkDelete( pNtk->pExdc );
src/base/abci/abc.c:        pNtk->pExdc = NULL;
src/base/abci/abc.c:    if ( pNtk->pExcare )
src/base/abci/abc.c:        Abc_NtkDelete( (Abc_Ntk_t *)pNtk->pExcare );
src/base/abci/abc.c:        pNtk->pExcare = NULL;
src/base/abci/abc.c:    if ( pNtk->pManTime == NULL )
src/base/abci/abc.c:            pNtk->nConstrs = nConstrs;
src/base/abci/abc.c:    ABC_FREE( pNtk->pSeqModel );
src/base/abci/abc.c:    Abc_FrameReplaceCex( pAbc, &pNtk->pSeqModel );
src/base/abci/abc.c:    ABC_FREE( pNtk->pSeqModel );
src/base/abci/abc.c:    Abc_FrameReplaceCex( pAbc, &pNtk->pSeqModel );
src/base/abci/abc.c:    vSeqModelVec = pNtk->vSeqModelVec;  pNtk->vSeqModelVec = NULL;
src/base/abci/abc.c:    if ( pNtk && pNtk->vPhases != NULL )
src/base/abci/abc.c:    Abc_FrameReplaceCex( pAbc, &pNtk->pSeqModel );
src/base/abci/abc.c:        int * pSimInfo = Abc_NtkVerifySimulatePattern( pNtk, pNtk->pModel );
src/base/abci/abc.c:            Abc_Print( -1, "%d", (int)(pNtk->pModel[i] > 0) );
src/base/abci/abc.c:        int * pSimInfo = Abc_NtkVerifySimulatePattern( pNtk, pNtk->pModel );
src/base/abci/abc.c:        pAbc->pCex = Abc_CexCreate( 0, Abc_NtkPiNum(pNtk), pNtk->pModel, 0, 0, 0 );
src/base/abci/abc.c:        int * pSimInfo = Abc_NtkVerifySimulatePattern( pNtk, pNtk->pModel );
src/base/abci/abc.c:            Abc_Print( -1, "%d", (int)(pNtk->pModel[i] > 0) );
src/base/abci/abc.c:    Abc_FrameReplaceCex( pAbc, &pNtk->pSeqModel );
src/base/abci/abc.c:    Abc_FrameReplaceCex( pAbc, &pNtk->pSeqModel );
src/base/abci/abc.c:    pAbc->nFrames = pNtk->vSeqModelVec ? -1 : pPars->iFrame;
src/base/abci/abc.c:    vSeqModelVec = pNtk->vSeqModelVec;  pNtk->vSeqModelVec = NULL;
src/base/abci/abc.c:        Abc_FrameReplaceCex( pAbc, &pNtk->pSeqModel );
src/base/abci/abc.c:            Abc_FrameReplaceCex( pAbc, &pNtk->pSeqModel );
src/base/abci/abc.c:        Abc_FrameReplaceCex( pAbc, &pNtk->pSeqModel );
src/base/abci/abc.c:        Abc_FrameReplaceCex( pAbc, &pNtk->pSeqModel );
src/base/abci/abc.c:        pNtk->nConstrs = 0;
src/base/abci/abc.c:        pNtk->nConstrs = nConstrs;
src/base/abci/abc.c:        pNtkRes->pName = Extra_UtilStrsav( pNtk->pName );
src/base/abci/abc.c:    pNtkNew->pName = Extra_UtilStrsav(pNtk->pName);
src/base/abci/abc.c:    pNtkNew->pName = Extra_UtilStrsav(pNtk->pName);
src/base/abci/abc.c:    pNtkNew->pSpec = Extra_UtilStrsav(pNtk->pSpec);
src/base/abci/abc.c:    pNtkNew->pName = Extra_UtilStrsav(pNtk->pName);
src/base/abci/abc.c:    if ( !Abc_HManVerify( 1, pNtk->Id ) )
src/base/abci/abc.c:        pGia->And2Delay = pNtk->AndGateDelay;
src/base/abci/abc.c:        pNtk->pName = Extra_UtilStrsav(pMan->pName);
src/base/abci/abc.c:                Nm_ManDeleteIdName(pNtk->pManName, pObj->Id);
src/base/abci/abc.c:                Nm_ManDeleteIdName(pNtk->pManName, pObj->Id);
src/base/abci/abcProve.c:  pNtk->pModel contains a satisfying assignment.]
src/base/abci/abcProve.c:            RetValue = ( (Abc_NtkNodeNum(pNtk) == 1) && (Abc_ObjFanin0(Abc_NtkPo(pNtk,0))->pData == Cudd_ReadLogicZero((DdManager *)pNtk->pManFunc)) );
src/base/abci/abcProve.c:    if ( RetValue == 0 && pNtk->pModel == NULL )
src/base/abci/abcProve.c:        pNtk->pModel = ABC_ALLOC( int, Abc_NtkCiNum(pNtk) );
src/base/abci/abcProve.c:        memset( pNtk->pModel, 0, sizeof(int) * Abc_NtkCiNum(pNtk) );
src/base/abci/abcMulti.c:    if ( pNtk->pExdc )
src/base/abci/abcMulti.c:        pNtkNew->pExdc = Abc_NtkDup( pNtk->pExdc );
src/base/abci/abcTiming.c:static inline Abc_Time_t * Abc_NodeArrival( Abc_Obj_t * pNode )  {  return (Abc_Time_t *)pNode->pNtk->pManTime->vArrs->pArray[pNode->Id];  }
src/base/abci/abcTiming.c:static inline Abc_Time_t * Abc_NodeRequired( Abc_Obj_t * pNode ) {  return (Abc_Time_t *)pNode->pNtk->pManTime->vReqs->pArray[pNode->Id];  }
src/base/abci/abcTiming.c:    assert( pNtk->pManTime );
src/base/abci/abcTiming.c:    return &pNtk->pManTime->tArrDef;
src/base/abci/abcTiming.c:    assert( pNtk->pManTime );
src/base/abci/abcTiming.c:    return &pNtk->pManTime->tReqDef;
src/base/abci/abcTiming.c:    assert( pNode->pNtk->pManTime );
src/base/abci/abcTiming.c:    assert( pNode->pNtk->pManTime );
src/base/abci/abcTiming.c:    return 0.5 * pNtk->pManTime->tArrDef.Rise + 0.5 * pNtk->pManTime->tArrDef.Fall;
src/base/abci/abcTiming.c:    return 0.5 * pNtk->pManTime->tReqDef.Rise + 0.5 * pNtk->pManTime->tReqDef.Fall;
src/base/abci/abcTiming.c:    assert( pNtk->pManTime );
src/base/abci/abcTiming.c:    return &pNtk->pManTime->tInDriveDef;
src/base/abci/abcTiming.c:    assert( pNtk->pManTime );
src/base/abci/abcTiming.c:    return &pNtk->pManTime->tOutLoadDef;
src/base/abci/abcTiming.c:    assert( pNtk->pManTime );
src/base/abci/abcTiming.c:    return pNtk->pManTime->tInDrive ? pNtk->pManTime->tInDrive + iPi : NULL;
src/base/abci/abcTiming.c:    assert( pNtk->pManTime );
src/base/abci/abcTiming.c:    return pNtk->pManTime->tOutLoad ? pNtk->pManTime->tOutLoad + iPo : NULL;
src/base/abci/abcTiming.c:    if ( pNtk->pManTime == NULL )
src/base/abci/abcTiming.c:        pNtk->pManTime = Abc_ManTimeStart(pNtk);
src/base/abci/abcTiming.c:    pNtk->pManTime->tArrDef.Rise  = Rise;
src/base/abci/abcTiming.c:    pNtk->pManTime->tArrDef.Fall  = Fall;
src/base/abci/abcTiming.c:    if ( pNtk->pManTime == NULL )
src/base/abci/abcTiming.c:        pNtk->pManTime = Abc_ManTimeStart(pNtk);
src/base/abci/abcTiming.c:    pNtk->pManTime->tReqDef.Rise  = Rise;
src/base/abci/abcTiming.c:    pNtk->pManTime->tReqDef.Fall  = Fall;
src/base/abci/abcTiming.c:    if ( pNtk->pManTime == NULL )
src/base/abci/abcTiming.c:        pNtk->pManTime = Abc_ManTimeStart(pNtk);
src/base/abci/abcTiming.c:    Abc_ManTimeExpand( pNtk->pManTime, ObjId + 1, 1 );
src/base/abci/abcTiming.c:    vTimes = pNtk->pManTime->vArrs;
src/base/abci/abcTiming.c:    if ( pNtk->pManTime == NULL )
src/base/abci/abcTiming.c:        pNtk->pManTime = Abc_ManTimeStart(pNtk);
src/base/abci/abcTiming.c:    Abc_ManTimeExpand( pNtk->pManTime, ObjId + 1, 1 );
src/base/abci/abcTiming.c:    vTimes = pNtk->pManTime->vReqs;
src/base/abci/abcTiming.c:    if ( pNtk->pManTime == NULL )
src/base/abci/abcTiming.c:        pNtk->pManTime = Abc_ManTimeStart(pNtk);
src/base/abci/abcTiming.c:    pNtk->pManTime->tInDriveDef.Rise  = Rise;
src/base/abci/abcTiming.c:    pNtk->pManTime->tInDriveDef.Fall  = Fall;
src/base/abci/abcTiming.c:    if ( pNtk->pManTime->tInDrive != NULL )
src/base/abci/abcTiming.c:            if ( pNtk->pManTime->tInDrive[i].Rise == 0 && pNtk->pManTime->tInDrive[i].Fall == 0 )
src/base/abci/abcTiming.c:                pNtk->pManTime->tInDrive[i] = pNtk->pManTime->tInDriveDef;
src/base/abci/abcTiming.c:    if ( pNtk->pManTime == NULL )
src/base/abci/abcTiming.c:        pNtk->pManTime = Abc_ManTimeStart(pNtk);
src/base/abci/abcTiming.c:    pNtk->pManTime->tOutLoadDef.Rise  = Rise;
src/base/abci/abcTiming.c:    pNtk->pManTime->tOutLoadDef.Fall  = Fall;
src/base/abci/abcTiming.c:    if ( pNtk->pManTime->tOutLoad != NULL )
src/base/abci/abcTiming.c:            if ( pNtk->pManTime->tOutLoad[i].Rise == 0 && pNtk->pManTime->tOutLoad[i].Fall == 0 )
src/base/abci/abcTiming.c:                pNtk->pManTime->tOutLoad[i] = pNtk->pManTime->tOutLoadDef;
src/base/abci/abcTiming.c:    if ( pNtk->pManTime == NULL )
src/base/abci/abcTiming.c:        pNtk->pManTime = Abc_ManTimeStart(pNtk);
src/base/abci/abcTiming.c:    if ( pNtk->pManTime->tInDriveDef.Rise == Rise && pNtk->pManTime->tInDriveDef.Fall == Fall )
src/base/abci/abcTiming.c:    if ( pNtk->pManTime->tInDrive == NULL )
src/base/abci/abcTiming.c:        pNtk->pManTime->tInDrive = ABC_CALLOC( Abc_Time_t, Abc_NtkCiNum(pNtk) );
src/base/abci/abcTiming.c:            pNtk->pManTime->tInDrive[i] = pNtk->pManTime->tInDriveDef;
src/base/abci/abcTiming.c:    pTime = pNtk->pManTime->tInDrive + PiNum;
src/base/abci/abcTiming.c:    if ( pNtk->pManTime == NULL )
src/base/abci/abcTiming.c:        pNtk->pManTime = Abc_ManTimeStart(pNtk);
src/base/abci/abcTiming.c:    if ( pNtk->pManTime->tOutLoadDef.Rise == Rise && pNtk->pManTime->tOutLoadDef.Fall == Fall )
src/base/abci/abcTiming.c:    if ( pNtk->pManTime->tOutLoad == NULL )
src/base/abci/abcTiming.c:        pNtk->pManTime->tOutLoad = ABC_CALLOC( Abc_Time_t, Abc_NtkCoNum(pNtk) );
src/base/abci/abcTiming.c:            pNtk->pManTime->tOutLoad[i] = pNtk->pManTime->tOutLoadDef;
src/base/abci/abcTiming.c:    pTime = pNtk->pManTime->tOutLoad + PoNum;
src/base/abci/abcTiming.c:    if ( pNtk->pManTime == NULL )
src/base/abci/abcTiming.c:    Abc_ManTimeExpand( pNtk->pManTime, Abc_NtkObjNumMax(pNtk), 0 );
src/base/abci/abcTiming.c:        pNtk->pManTime->tArrDef = pNtkOld->pManTime->tArrDef;
src/base/abci/abcTiming.c:        pNtk->pManTime->tReqDef = pNtkOld->pManTime->tReqDef;
src/base/abci/abcTiming.c:        pNtk->AndGateDelay = pNtkOld->AndGateDelay;
src/base/abci/abcTiming.c:    ppTimes = (Abc_Time_t **)pNtk->pManTime->vArrs->pArray;
src/base/abci/abcTiming.c:        *ppTimes[pObj->Id] = pNtkOld ? *Abc_NodeReadArrival(Abc_NtkCi(pNtkOld, i)) : pNtk->pManTime->tArrDef;
src/base/abci/abcTiming.c:    ppTimes = (Abc_Time_t **)pNtk->pManTime->vReqs->pArray;
src/base/abci/abcTiming.c:        *ppTimes[pObj->Id] = pNtkOld ? *Abc_NodeReadRequired(Abc_NtkCo(pNtkOld, i)) : pNtk->pManTime->tReqDef;
src/base/abci/abcTiming.c:    if ( pNtk->pManTime == NULL )
src/base/abci/abcTiming.c:    pNtk->pManTime->tArrDef.Fall *= Scale;
src/base/abci/abcTiming.c:    pNtk->pManTime->tArrDef.Rise *= Scale;
src/base/abci/abcTiming.c:    pNtk->pManTime->tReqDef.Fall *= Scale;
src/base/abci/abcTiming.c:    pNtk->pManTime->tReqDef.Rise *= Scale;
src/base/abci/abcTiming.c:    ppTimes = (Abc_Time_t **)pNtk->pManTime->vArrs->pArray;
src/base/abci/abcTiming.c:    ppTimes = (Abc_Time_t **)pNtk->pManTime->vReqs->pArray;
src/base/abci/abcTiming.c:    if ( pNtk->pManTime == NULL )
src/base/abci/abcTiming.c:        pNtk->pManTime = Abc_ManTimeStart(pNtk);
src/base/abci/abcTiming.c:    Abc_ManTimeExpand( pNtk->pManTime, Abc_NtkObjNumMax(pNtk), 0 );
src/base/abci/abcTiming.c:    ppTimes = (Abc_Time_t **)pNtk->pManTime->vArrs->pArray;
src/base/abci/abcTiming.c:    ppTimes = (Abc_Time_t **)pNtk->pManTime->vReqs->pArray;
src/base/abci/abcTiming.c:    p = pNtk->pManTime = ABC_ALLOC( Abc_ManTime_t, 1 );
src/base/abci/abcTiming.c:      vTimes = pNtk->pManTime->vArrs;
src/base/abci/abcTiming.c:      vTimes = pNtk->pManTime->vArrs;
src/base/abci/abcTiming.c:    if ( pNtk->pManTime == NULL )
src/base/abci/abcTiming.c:        printf( "Default arrival = %8f\n", pNtk->pManTime->tArrDef.Fall );
src/base/abci/abcTiming.c:        printf( "Default required = %8f\n", pNtk->pManTime->tReqDef.Fall );
src/base/abci/abcTiming.c:    if ( pNtk->pManTime == NULL )
src/base/abci/abcTiming.c:    if ( pNtk->pManTime == NULL )
src/base/abci/abcTiming.c:    if ( pNtk->pManTime == NULL )
src/base/abci/abcTiming.c:    if ( pNtk->pManTime == NULL )
src/base/abci/abcTiming.c:    assert( pNtk->vLevelsR );
src/base/abci/abcTiming.c:    return pNtk->LevelMax + 1 - Abc_ObjReverseLevel(pObj);
src/base/abci/abcTiming.c:    assert( pNtk->vLevelsR );
src/base/abci/abcTiming.c:    Vec_IntFillExtra( pNtk->vLevelsR, pObj->Id + 1, 0 );
src/base/abci/abcTiming.c:    return Vec_IntEntry(pNtk->vLevelsR, pObj->Id);
src/base/abci/abcTiming.c:    assert( pNtk->vLevelsR );
src/base/abci/abcTiming.c:    Vec_IntFillExtra( pNtk->vLevelsR, pObj->Id + 1, 0 );
src/base/abci/abcTiming.c:    Vec_IntWriteEntry( pNtk->vLevelsR, pObj->Id, LevelR );
src/base/abci/abcTiming.c:    pNtk->LevelMax = Abc_NtkLevel(pNtk) + nMaxLevelIncrease;
src/base/abci/abcTiming.c:    pNtk->vLevelsR = Vec_IntAlloc( 0 );
src/base/abci/abcTiming.c:    Vec_IntFill( pNtk->vLevelsR, 1 + Abc_NtkObjNumMax(pNtk), 0 );
src/base/abci/abcTiming.c:    assert( pNtk->vLevelsR );
src/base/abci/abcTiming.c:    Vec_IntFree( pNtk->vLevelsR );
src/base/abci/abcTiming.c:    pNtk->vLevelsR = NULL;
src/base/abci/abcTiming.c:    pNtk->LevelMax = 0;
src/base/ver/verCore.c:            sprintf( pMan->sError, "The network check has failed for network %s.", pNtk->pName );
src/base/ver/verCore.c:        if ( pNtk->ntkFunc == ABC_FUNC_BLACKBOX )
src/base/ver/verCore.c:            assert( pNtk->pManFunc == NULL );
src/base/ver/verCore.c:            pNtk->ntkFunc = ABC_FUNC_MAP;
src/base/ver/verCore.c:            pNtk->pManFunc = pMan->pDesign->pGenlib;
src/base/ver/verCore.c:        else if ( pNtk->ntkFunc != ABC_FUNC_MAP )
src/base/ver/verCore.c:            sprintf( pMan->sError, "The network %s appears to have both gates and assign statements. Currently such network are not allowed. One way to fix this problem might be to replace assigns by buffers from the library.", pNtk->pName );
src/base/ver/verCore.c:        if ( pNtk->ntkFunc == ABC_FUNC_BLACKBOX )
src/base/ver/verCore.c:            assert( pNtk->pManFunc == NULL );
src/base/ver/verCore.c:            pNtk->ntkFunc = ABC_FUNC_AIG;
src/base/ver/verCore.c:            pNtk->pManFunc = pMan->pDesign->pManFunc;
src/base/ver/verCore.c:        else if ( pNtk->ntkFunc != ABC_FUNC_AIG )
src/base/ver/verCore.c:            sprintf( pMan->sError, "The network %s appears to have both gates and assign statements. Currently such network are not allowed. One way to fix this problem might be to replace assigns by buffers from the library.", pNtk->pName );
src/base/ver/verCore.c:        sprintf( pMan->sError, "Cannot find \"(\" after \"module\" in network %s.", pNtk->pName );
src/base/ver/verCore.c:    if ( pNtk->ntkFunc == ABC_FUNC_BLACKBOX )
src/base/ver/verCore.c:                    pFunc = Hop_ManConst0((Hop_Man_t *)pNtk->pManFunc);
src/base/ver/verCore.c:                    pFunc = Hop_ManConst1((Hop_Man_t *)pNtk->pManFunc);
src/base/ver/verCore.c:                    pFunc = (Hop_Obj_t *)Ver_FormulaReduction( pEquation, pNtk->pManFunc, pMan->vNames, pMan->sError );  
src/base/ver/verCore.c:                    pFunc = (Hop_Obj_t *)Ver_FormulaParser( pEquation, pNtk->pManFunc, pMan->vNames, pMan->vStackFn, pMan->vStackOp, pMan->sError );  
src/base/ver/verCore.c:        pNode->pData = Hop_CreateAnd( (Hop_Man_t *)pNtk->pManFunc, Abc_ObjFaninNum(pNode) );
src/base/ver/verCore.c:        pNode->pData = Hop_CreateOr( (Hop_Man_t *)pNtk->pManFunc, Abc_ObjFaninNum(pNode) );
src/base/ver/verCore.c:        pNode->pData = Hop_CreateExor( (Hop_Man_t *)pNtk->pManFunc, Abc_ObjFaninNum(pNode) );
src/base/ver/verCore.c:        pNode->pData = Hop_CreateAnd( (Hop_Man_t *)pNtk->pManFunc, Abc_ObjFaninNum(pNode) );
src/base/ver/verCore.c:            if ( pNtk->pData == NULL )
src/base/ver/verCore.c:                pNtk->pData = Extra_MmFlexStart();
src/base/ver/verCore.c:        pNtk->pData = NULL;
src/base/ver/verCore.c:        pNtk->fHiePath = 0;
src/base/ver/verCore.c:            printf( "%s (%d)  ", Abc_NtkName(pNtk), pNtk->fHiePath );
src/base/ver/verCore.c:        pNtk->fHiePath = 0;
src/base/ver/verCore.c:        Vec_PtrForEachEntry( Abc_Obj_t *, (Vec_Ptr_t *)pNtk->pData, pBox, k )
src/base/ver/verCore.c:    Vec_PtrForEachEntry( Abc_Obj_t *, (Vec_Ptr_t *)pNtk->pData, pBox, k )
src/base/ver/verCore.c:    Vec_PtrForEachEntry( Abc_Obj_t *, (Vec_Ptr_t *)pNtk->pData, pBox, k )
src/base/ver/verCore.c:    Vec_PtrForEachEntry( Abc_Obj_t *, (Vec_Ptr_t *)pNtk->pData, pBox, k )
src/base/ver/verCore.c:        Vec_PtrForEachEntry( Abc_Obj_t *, (Vec_Ptr_t *)pNtk->pData, pBox, k )
src/base/ver/verCore.c:                    CountCur, CountTotal, pNtk->pName, Abc_ObjName(pBox) );
src/base/ver/verCore.c:        pBox = (Abc_Obj_t *)Vec_PtrEntry( (Vec_Ptr_t *)pNtk->pData, 0 );
src/base/ver/verCore.c:        Vec_PtrForEachEntry( Abc_Obj_t *, (Vec_Ptr_t *)pNtk->pData, pBox, k )
src/base/ver/verCore.c:        Vec_PtrForEachEntry( Abc_Obj_t *, (Vec_Ptr_t *)pNtk->pData, pBox, k )
src/base/ver/verCore.c:        pNtk->fHieVisited = 0;
src/base/ver/verCore.c:        fprintf( pFile, " instantiated %6d times ", pNtk->fHieVisited );
src/base/ver/verCore.c:        pNtk->fHieVisited = 0;
src/base/ver/verCore.c:        Vec_PtrFree( (Vec_Ptr_t *)pNtk->pData );
src/base/ver/verCore.c:        pNtk->pData = NULL;
src/base/bac/bacBac.c:    Bac_ManReadBacVecStr( vOut, pPos, &pNtk->vType,      Bac_NtkObjNumAlloc(pNtk) );
src/base/bac/bacBac.c:    Bac_ManReadBacVecInt( vOut, pPos, &pNtk->vFanin, 4 * Bac_NtkObjNumAlloc(pNtk) );
src/base/bac/bacBac.c:    Bac_ManReadBacVecInt( vOut, pPos, &pNtk->vInfo, 12 * Bac_NtkInfoNumAlloc(pNtk) );
src/base/bac/bacBac.c:            Vec_IntPush( &pNtk->vInputs, i );
src/base/bac/bacBac.c:            Vec_IntPush( &pNtk->vOutputs, i );
src/base/bac/bacBac.c:        Vec_IntFill( &pNtk->vInfo, 3 * Num4, -1 );
src/base/bac/bacBac.c:    Vec_StrPushBuffer( vOut, (char *)Vec_StrArray(&pNtk->vType),       Bac_NtkObjNum(pNtk) );
src/base/bac/bacBac.c:    Vec_StrPushBuffer( vOut, (char *)Vec_IntArray(&pNtk->vFanin),  4 * Bac_NtkObjNum(pNtk) );
src/base/bac/bacBac.c:    Vec_StrPushBuffer( vOut, (char *)Vec_IntArray(&pNtk->vInfo),  12 * Bac_NtkInfoNum(pNtk) );
src/base/bac/bacNtk.c:        pNtk->Count = -1;
src/base/bac/bac.h:        pNtk->pDesign = pNew;
src/base/bac/bac.h:        pNtk->pDesign = pNew;
src/base/bac/bac.h:        pNtk->Count = -1;
src/base/bac/bacReadVer.c:                p->pNtk->fHasC0s = 1;
src/base/bac/bacReadVer.c:                p->pNtk->fHasC1s = 1;
src/base/bac/bacReadVer.c:                p->pNtk->fHasCXs = 1;
src/base/bac/bacReadVer.c:                p->pNtk->fHasCZs = 1;
src/base/bac/bacReadVer.c:        p->pNtk->fHasC0s = 1;
src/base/bac/bacReadVer.c:                p->pNtk->fHasC1s = 1;
src/base/bac/bacReadVer.c:        p->pNtk->fHasC0s = 1;
src/base/bac/bacReadVer.c:                p->pNtk->fHasC1s = 1;
src/base/bac/bacReadVer.c:    Vec_Int_t * vNames[4]  = { &p->pNtk->vInputs,  &p->pNtk->vOutputs,  &p->pNtk->vInouts,  &p->pNtk->vWires };
src/base/bac/bacReadVer.c:    Vec_Int_t * vNamesR[4] = { &p->pNtk->vInputsR, &p->pNtk->vOutputsR, &p->pNtk->vInoutsR, &p->pNtk->vWiresR };
src/base/bac/bacReadVer.c:            Vec_IntPush( &p->pNtk->vOrder, Abc_Var2Lit2(NameId, Type) );
src/base/bac/bacReadVer.c:    Vec_Int_t * vSigs[3]  = { &p->pNtk->vInputs,  &p->pNtk->vOutputs,  &p->pNtk->vInouts  };
src/base/bac/bacReadVer.c:    Vec_Int_t * vSigsR[3] = { &p->pNtk->vInputsR, &p->pNtk->vOutputsR, &p->pNtk->vInoutsR };
src/base/bac/bacReadVer.c:            Vec_IntPush( &p->pNtk->vOrder, Abc_Var2Lit2(iName, iType) );
src/base/bac/bacReadVer.c:            Vec_IntPush( &p->vSucceeded, p->pNtk->iModuleName );
src/base/bac/bacReadVer.c:                //    Abc_NamStr(p->pStrs, iToken), Abc_NamStr(p->pStrs, p->pNtk->iModuleName) );
src/base/bac/bacReadVer.c:                Vec_IntPush( &p->vFailed, p->pNtk->iModuleName );
src/base/bac/bacReadVer.c:                Vec_IntErase( &p->pNtk->vWires );
src/base/bac/bacReadVer.c:                Vec_IntErase( &p->pNtk->vWiresR );
src/base/bac/bacReadVer.c:                Vec_IntErase( &p->pNtk->vSlices );
src/base/bac/bacReadVer.c:                Vec_IntErase( &p->pNtk->vConcats );
src/base/bac/bacReadVer.c:                Vec_IntErase( &p->pNtk->vBoxes );
src/base/bac/bacReadVer.c:                Vec_IntErase( &p->pNtk->vObjs );
src/base/bac/bacWriteBlif.c:    fprintf( pFile, "# Design \"%s\" written by ABC on %s\n\n", Psr_NtkStr(pNtk, pNtk->iModuleName), Extra_TimeStamp() );
src/base/bac/bacReadBlif.c:        p->pNtk->fHasC0s = 1;
src/base/bac/bacReadBlif.c:            p->pNtk->fHasC0s = 1;
src/base/bac/bacReadBlif.c:            p->pNtk->fHasC1s = 1;
src/base/bac/bacReadBlif.c:    if ( Psr_ManReadList(p, &p->pNtk->vOrder, 3) )    return 1;
src/base/bac/bacReadBlif.c:    Vec_IntAppend( &p->pNtk->vInouts, &p->vTemp );
src/base/bac/bacReadBlif.c:    if ( Psr_ManReadList(p, &p->pNtk->vOrder, 1) )    return 1;
src/base/bac/bacReadBlif.c:    Vec_IntAppend( &p->pNtk->vInputs, &p->vTemp );
src/base/bac/bacReadBlif.c:    if ( Psr_ManReadList(p, &p->pNtk->vOrder, 2) )    return 1;
src/base/bac/bacReadBlif.c:    Vec_IntAppend( &p->pNtk->vOutputs, &p->vTemp );
src/base/bac/bacReadBlif.c:    if ( fGate ) p->pNtk->fMapped = 1;
src/base/bac/bacPtrAbc.c:    vDes = Vec_PtrAllocExact( 1 + Vec_PtrSize(pNtk->pDesign->vModules) );
src/base/bac/bacPtrAbc.c:    Vec_PtrPush( vDes, pNtk->pDesign->pName );
src/base/bac/bacPtrAbc.c:    Vec_PtrForEachEntry( Abc_Ntk_t *, pNtk->pDesign->vModules, pTemp, i )
src/base/bac/bacPtrAbc.c:    char * pFileName = Extra_FileNameGenericAppend(pNtk->pDesign->pName, "_out.blif");
src/base/bac/bacPtrAbc.c:    int ModuleId = Bac_ManNtkFindId( pNtk->pDesign, pBoxNtk );
src/base/bac/bacPtrAbc.c:    return Bac_NtkPoNumAlloc( Bac_ManNtk(pNtk->pDesign, ModuleId) );
src/base/bac/bacPtrAbc.c:    NameId = Abc_NamStrFindOrAdd( pNtk->pDesign->pStrs, pModuleName, NULL );
src/base/bac/bacPtrAbc.c:        NameId = Abc_NamStrFindOrAdd( pNtk->pDesign->pStrs, pName, NULL );
src/base/bac/bacPtrAbc.c:        int NtkId = Bac_ManNtkFindId( pNtk->pDesign, pBoxNtk );
src/base/bac/bacPtrAbc.c:            Bac_NtkSetHost( Bac_ManNtk(pNtk->pDesign, NtkId), Bac_NtkId(pNtk), iObj );
src/base/bac/bacPtrAbc.c:        Bac_ObjSetName( pNtk, iObj, Abc_Var2Lit2(Abc_NamStrFindOrAdd(pNtk->pDesign->pStrs, pBoxName, NULL), BAC_NAME_BIN) );
src/base/bac/bacPtrAbc.c:            NameId = Abc_NamStrFindOrAdd( pNtk->pDesign->pStrs, pName, NULL );
src/base/bac/bacPtrAbc.c:            NameId = Abc_NamStrFindOrAdd( pNtk->pDesign->pStrs, pName, NULL );
src/base/bac/bacPtrAbc.c:        NameId = Abc_NamStrFindOrAdd( pNtk->pDesign->pStrs, pName, NULL );
src/base/bac/bacPtrAbc.c:    assert( Bac_NtkObjNum(pNtk) == Vec_StrCap(&pNtk->vType) );
src/base/bac/bacPrsBuild.c:    Vec_IntForEachEntry( &pNtk->vOrder, NameId, i )
src/base/bac/bacPrsBuild.c:    Vec_Int_t * vMap = Vec_IntStartFull( Abc_NamObjNumMax(pNtk->pStrs) + 1 );
src/base/bac/bacPrsBuild.c:    pNew->pStrs = Abc_NamRef( pNtk->pStrs );  
src/base/bac/bacPrsBuild.c:    if ( (pNtk->fMapped || (pNtk->fSlices && Psr_ManIsMapped(pNtk))) && !Bac_NtkBuildLibrary(pNew) )
src/base/bac/bacBlast.c:    assert( Vec_IntSize(&p->vBuf2LeafNtk) == pNtk->nBarBufs2 );
src/base/bac/bacBlast.c:    assert( Count == pNtk->nBarBufs2 );
src/base/bac/bacBlast.c:    Bac_NtkPrepareLibrary( p, (Mio_Library_t *)pNtk->pManFunc );
src/base/bac/bacBlast.c:    p->pMioLib = pNtk->pManFunc;
src/base/bac/bacBlast.c:    assert( Count == pNtk->nBarBufs2 );
src/base/bac/bacWriteVer.c:    fprintf( pFile, "// Design \"%s\" written by ABC on %s\n\n", Psr_NtkStr(pNtk, pNtk->iModuleName), Extra_TimeStamp() );
src/base/bac/bacPrs.h:    p->pNtk->iModuleName = iName;
src/base/bac/bacPrs.h:    p->pNtk->fSlices = fSlices;
src/base/bac/bacPrs.h:    p->pNtk->pStrs = Abc_NamRef( p->pStrs );
src/base/wln/wlnNdr.c:    //pNtk->pSpec = Abc_UtilStrsav( pFileName );
src/base/wln/wlnNdr.c:            Wln_ObjSetSlice( pNtk, iObj, Hash_Int2ManInsert(pNtk->pRanges, End, Beg, 0) );
src/base/wln/wlnNdr.c:    //Vec_IntPrint( &pNtk->vInstIds );
src/base/wln/wlnNdr.c:    if ( Vec_IntCountPositive(&pNtk->vInstIds) == 0 )
src/base/wln/wlnNdr.c:        Vec_IntErase( &pNtk->vInstIds );
src/base/wln/wlnNdr.c:    vName2Obj = Vec_IntInvert( &pNtk->vNameIds, 0 );
src/base/wln/wlnNdr.c:    NameIdMax = Vec_IntFindMax(&pNtk->vNameIds);
src/base/wln/wlnNdr.c:    pNtk->pManName = Abc_NamStart( NameIdMax+1, 10 );
src/base/wln/wlnNdr.c:        NameId = Abc_NamStrFindOrAdd( pNtk->pManName, pName, &fFound );
src/base/wln/wlnNdr.c:            Wln_ObjSetConst( pNtk, iObj, Abc_NamStrFindOrAdd(pNtk->pManName, (char *)Vec_PtrEntry(vConstStrings, i++), NULL) );
src/base/wln/wlnNdr.c:    printf( "Dumped design \"%s\" into file \"temp_ndr.v\".\n", pNtk->pName );
src/base/wln/wlnNdr.c:    //pNtk->fMemPorts = 1;          // the network contains memory ports
src/base/wln/wlnNdr.c:    //pNtk->fEasyFfs = 1;           // the network contains simple flops
src/base/wln/wlnRetime.c:    printf( "Printing %d objects of network \"%s\":\n", Wln_NtkObjNum(p->pNtk), p->pNtk->pName );
src/base/wln/wlnRetime.c:    Wln_NtkStartFanoutMap( pNtk, &p->vFanouts, &pNtk->vRefs, 2 );
src/base/wln/wlnRetime.c:    ABC_SWAP( Vec_Int_t, *vRefsCopy, pNtk->vRefs );
src/base/wln/wlnRetime.c:    //ABC_SWAP( Vec_Int_t, p->vNodeDelays, pNtk->vInstIds );
src/base/wln/wlnRetime.c:    Vec_IntAppend( &p->vNodeDelays, &pNtk->vInstIds );
src/base/wln/wlnRetime.c:        int NameId = Vec_IntEntry( &p->pNtk->vNameIds, iObj );
src/base/wln/wlnRetime.c://        Vec_IntErase( &pNtk->vInstIds );
src/base/wln/wlnRead.c:        if ( pNtk->NameId == NameId )
src/base/wln/wlnRead.c:        pNtk->iCopy = -1;
src/base/wln/wlnRead.c:        if ( pNtk->iCopy == -1 )
src/base/wln/wlnRead.c:    if ( pNtk->iCopy == -1 )
src/base/wln/wlnRead.c:    assert( pNtk->iCopy == -2 );
src/base/wln/wlnRead.c:    pNtk->iCopy = -1;
src/base/wln/wlnRead.c:        pNtk->iCopy = -1;
src/base/wln/wlnRead.c:            pNtk->iCopy = -2;//, pNtk->fRoot = 0;
src/base/wln/wlnRead.c:            //pNtk->fRoot = fInv;
src/base/wln/wlnRead.c:        if ( pNtk->iCopy == -1 && pNtk->pGia == NULL )
src/base/wln/wlnRead.c:            pNtk->pGia = Rtl_NtkBlast2( pNtk );
src/base/wln/wlnRead.c://        if ( pNtk->iCopy == -2 )
src/base/wln/wlnRead.c:        pNtk->iCopy = -1;
src/base/wln/wlnRead.c:        Gia_ManStopP( &pNtk->pGia );
src/base/wln/wlnRead.c:        pNtk->iCopy = -1;
src/base/wln/wlnRead.c:    Rtl_NtkPrintBufs( pNtk, pNtk->pGia->vBarBufs );
src/base/wln/wlnRead.c:            pNtk->iCopy = -1;
src/base/wln/wlnRead.c:                pNtk->iCopy = -1;
src/base/wln/wlnRead.c:            pNtk->fRoot = 0;
src/base/wln/wlnRead.c:        pNtk->fRoot = 1;
src/base/acb/acbMfs.c:        while ( (Value = (int)Vec_QueTopPriority(pNtk->vQue)) > 0 )
src/base/acb/acbMfs.c:            int iObj = Vec_QuePop(pNtk->vQue);
src/base/acb/acb.h:        assert( NtkId == pNtk->Id );
src/base/acb/acbUtil.c:            printf( "Cannot find name \"%s\" in the network \"%s\".\n", pName, pNtk->pDesign->pName );
src/base/acb/acbUtil.c:    Acb_ManFree( pNtk->pDesign );
src/base/acb/acbUtil.c:    Vec_IntClear( &pNtk->vArray0 );
src/base/acb/acbAbc.c:    pNtk->nFaninMax = 6;
src/base/acb/acbAbc.c:    pNtk->nFaninMax = 6;
src/base/acb/acbAbc.c:        Vec_IntPush( &pNtk->vTargets, ObjId );
src/base/acb/acbFunc.c:    Acb_ManFree( pNtk->pDesign );
src/base/cba/cbaReadVer.c:                p->pNtk->fHasC0s = 1;
src/base/cba/cbaReadVer.c:                p->pNtk->fHasC1s = 1;
src/base/cba/cbaReadVer.c:                p->pNtk->fHasCXs = 1;
src/base/cba/cbaReadVer.c:                p->pNtk->fHasCZs = 1;
src/base/cba/cbaReadVer.c:        p->pNtk->fHasC0s = 1;
src/base/cba/cbaReadVer.c:                p->pNtk->fHasC1s = 1;
src/base/cba/cbaReadVer.c:        p->pNtk->fHasC0s = 1;
src/base/cba/cbaReadVer.c:                p->pNtk->fHasC1s = 1;
src/base/cba/cbaReadVer.c:    Vec_Int_t * vNames[4]  = { &p->pNtk->vInputs,  &p->pNtk->vOutputs,  &p->pNtk->vInouts,  &p->pNtk->vWires };
src/base/cba/cbaReadVer.c:    Vec_Int_t * vNamesR[4] = { &p->pNtk->vInputsR, &p->pNtk->vOutputsR, &p->pNtk->vInoutsR, &p->pNtk->vWiresR };
src/base/cba/cbaReadVer.c:            Vec_IntPush( &p->pNtk->vOrder, Abc_Var2Lit2(NameId, Type) );
src/base/cba/cbaReadVer.c:    Vec_Int_t * vSigs[3]  = { &p->pNtk->vInputs,  &p->pNtk->vOutputs,  &p->pNtk->vInouts  };
src/base/cba/cbaReadVer.c:    Vec_Int_t * vSigsR[3] = { &p->pNtk->vInputsR, &p->pNtk->vOutputsR, &p->pNtk->vInoutsR };
src/base/cba/cbaReadVer.c:            Vec_IntPush( &p->pNtk->vOrder, Abc_Var2Lit2(iName, iType) );
src/base/cba/cbaReadVer.c:            Vec_IntPush( &p->vSucceeded, p->pNtk->iModuleName );
src/base/cba/cbaReadVer.c:                //    Abc_NamStr(p->pStrs, iToken), Abc_NamStr(p->pStrs, p->pNtk->iModuleName) );
src/base/cba/cbaReadVer.c:                Vec_IntPush( &p->vFailed, p->pNtk->iModuleName );
src/base/cba/cbaReadVer.c:                Vec_IntErase( &p->pNtk->vWires );
src/base/cba/cbaReadVer.c:                Vec_IntErase( &p->pNtk->vWiresR );
src/base/cba/cbaReadVer.c:                Vec_IntErase( &p->pNtk->vSlices );
src/base/cba/cbaReadVer.c:                Vec_IntErase( &p->pNtk->vConcats );
src/base/cba/cbaReadVer.c:                Vec_IntErase( &p->pNtk->vBoxes );
src/base/cba/cbaReadVer.c:                Vec_IntErase( &p->pNtk->vObjs );
src/base/cba/cbaReadVer.c:            return Abc_NamStr(pNtk->pStrs, Abc_Lit2Var2(ActId));
src/base/cba/cbaReadVer.c:    int NameRamId = Abc_NamStrFind( pNtk->pStrs, "Ram" );
src/base/cba/cbaReadVer.c:    assert( Vec_IntSize(&pNtk->vInouts) == 0 );
src/base/cba/cbaReadVer.c:    Vec_IntForEachEntryTwo( &pNtk->vInputs, &pNtk->vInputsR, NameId, RangeId, i )
src/base/cba/cbaReadVer.c:    Vec_IntForEachEntryTwo( &pNtk->vOutputs, &pNtk->vOutputsR, NameId, RangeId, i )
src/base/cba/cbaReadVer.c:    Vec_IntForEachEntry( &pNtk->vOrder, NameId, i )
src/base/cba/cbaReadVer.c:    Vec_IntForEachEntryTwo( &pNtk->vWires, &pNtk->vWiresR, NameId, RangeId, i )
src/base/cba/cbaReadVer.c:    Vec_IntForEachEntryTwo( &pNtk->vOutputs, &pNtk->vOutputsR, NameId, RangeId, i )
src/base/cba/cbaReadVer.c:    Vec_IntForEachEntryTwo( &pNtk->vOutputs, &pNtk->vOutputsR, NameId, RangeId, i )
src/base/cba/cbaWriteVer.c:    fprintf( pFile, "// Design \"%s\" written by ABC on %s\n\n", Prs_NtkStr(pNtk, pNtk->iModuleName), Extra_TimeStamp() );
src/base/cba/cbaPrs.h:    p->pNtk->iModuleName = iName;
src/base/cba/cbaPrs.h:    p->pNtk->fSlices = fSlices;
src/base/cba/cbaPrs.h:    p->pNtk->pStrs = Abc_NamRef( p->pStrs );
src/base/cba/cbaPrs.h:    p->pNtk->pFuns = Abc_NamRef( p->pFuns );
src/base/cba/cbaPrs.h:    p->pNtk->vHash = Hash_IntManRef( p->vHash );
src/base/cba/cbaReadBlif.c:        p->pNtk->fHasC0s = 1;
src/base/cba/cbaReadBlif.c:            p->pNtk->fHasC0s = 1;
src/base/cba/cbaReadBlif.c:            p->pNtk->fHasC1s = 1;
src/base/cba/cbaReadBlif.c:    if ( Prs_ManReadList(p, &p->pNtk->vOrder, 3) )    return 1;
src/base/cba/cbaReadBlif.c:    Vec_IntAppend( &p->pNtk->vInouts, &p->vTemp );
src/base/cba/cbaReadBlif.c:    if ( Prs_ManReadList(p, &p->pNtk->vOrder, 1) )    return 1;
src/base/cba/cbaReadBlif.c:    Vec_IntAppend( &p->pNtk->vInputs, &p->vTemp );
src/base/cba/cbaReadBlif.c:    if ( Prs_ManReadList(p, &p->pNtk->vOrder, 2) )    return 1;
src/base/cba/cbaReadBlif.c:    Vec_IntAppend( &p->pNtk->vOutputs, &p->vTemp );
src/base/cba/cbaReadBlif.c:    if ( fGate ) p->pNtk->fMapped = 1;
src/base/cba/cba.h:        assert( NtkId == pNtk->Id );
src/base/cba/cbaWriteBlif.c:    fprintf( pFile, "# Design \"%s\" written by ABC on %s\n\n", Prs_NtkStr(pNtk, pNtk->iModuleName), Extra_TimeStamp() );
src/base/wlc/wlcNdr.c:    Vec_IntClear( &pNtk->vFfs );
src/base/wlc/wlcNdr.c:    //pNtk->pSpec = Abc_UtilStrsav( pFileName );
src/base/wlc/wlcNdr.c:            if ( pNtk->vInits == NULL )
src/base/wlc/wlcNdr.c:                pNtk->vInits = Vec_IntAlloc( 100 );
src/base/wlc/wlcNdr.c:                Vec_IntPush( pNtk->vInits, Vec_IntPop(vFanins) );
src/base/wlc/wlcNdr.c:                Vec_IntPush( pNtk->vInits, -(End-Beg+1) );
src/base/wlc/wlcNdr.c:            Vec_IntPush( &pNtk->vFfs, NameId );
src/base/wlc/wlcNdr.c:            Vec_IntPush( &pNtk->vFfs, Vec_IntEntry(vFanins, 0) );
src/base/wlc/wlcNdr.c:            Vec_IntPush( &pNtk->vFfs2, iObj );
src/base/wlc/wlcNdr.c:    vName2Obj = Vec_IntInvert( &pNtk->vNameIds, 0 );
src/base/wlc/wlcNdr.c:    if ( pNtk->vInits )
src/base/wlc/wlcNdr.c:        Vec_IntForEachEntry( &pNtk->vFfs, NameId, i )
src/base/wlc/wlcNdr.c:            Vec_IntWriteEntry( &pNtk->vFfs, i, Vec_IntEntry(vName2Obj, NameId) );
src/base/wlc/wlcNdr.c:        Vec_IntForEachEntry( pNtk->vInits, NameId, i )
src/base/wlc/wlcNdr.c:                Vec_IntWriteEntry( pNtk->vInits, i, Vec_IntEntry(vName2Obj, NameId) );
src/base/wlc/wlcNdr.c:        assert( (Vec_IntSize(&pNtk->vFfs) & 1) == 0 );
src/base/wlc/wlcNdr.c:        assert( Vec_IntSize(&pNtk->vFfs) == 2 * Vec_IntSize(pNtk->vInits) );
src/base/wlc/wlcNdr.c:        Vec_IntClear( &pNtk->vFfs );
src/base/wlc/wlcNdr.c:        //Vec_IntPrint( &p->pNtk->vInits );
src/base/wlc/wlcNdr.c:        pNtk->pInits = Wlc_PrsConvertInitValues( pNtk );
src/base/wlc/wlcNdr.c:        //printf( "%s", p->pNtk->pInits );
src/base/wlc/wlcNdr.c:    NameIdMax = Vec_IntFindMax(&pNtk->vNameIds);
src/base/wlc/wlcNdr.c:    pNtk->pManName = Abc_NamStart( NameIdMax+1, 10 );
src/base/wlc/wlcNdr.c:        NameId = Abc_NamStrFindOrAdd( pNtk->pManName, pName, &fFound );
src/base/wlc/wlcNdr.c:        pNtk->vLutTruths = Vec_WrdStart( Wlc_NtkObjNumMax(pNtk) );
src/base/wlc/wlcNdr.c:            Vec_WrdWriteEntry( pNtk->vLutTruths, iObj, Truth );
src/base/wlc/wlcNdr.c:    pNtk->fMemPorts = 1;          // the network contains memory ports
src/base/wlc/wlcNdr.c:    pNtk->fEasyFfs = 1;           // the network contains simple flops
src/base/wlc/wlcReadSmt.c:    NameId = Abc_NamStrFindOrAdd( pNtk->pManName, pName, &fFound );
src/base/wlc/wlcReadSmt.c:        NameId = Abc_NamStrFindOrAdd( pNtk->pManName, pNameFanin, &fFound );
src/base/wlc/wlcReadSmt.c:            NameId = Abc_NamStrFindOrAdd( pNtk->pManName, pNameFanin, &fFound );
src/base/wlc/wlcReadSmt.c:            NameId = Abc_NamStrFindOrAdd( pNtk->pManName, pNameFanin, &fFound );
src/base/wlc/wlcReadSmt.c:            NameId = Abc_NamStrFindOrAdd( pNtk->pManName, pNameFanin, &fFound );
src/base/wlc/wlcReadSmt.c:            NameId = Abc_NamStrFindOrAdd( pNtk->pManName, pNameFanin, &fFound );
src/base/wlc/wlcReadSmt.c:    NameId = Abc_NamStrFindOrAdd( pNtk->pManName, pName, &fFound );
src/base/wlc/wlcReadSmt.c:            int fFound, iObj = Abc_NamStrFindOrAdd( pNtk->pManName, pStr, &fFound );
src/base/wlc/wlcReadSmt.c:            int fFound, iObj = Abc_NamStrFindOrAdd( pNtk->pManName, pStr, &fFound );
src/base/wlc/wlcReadSmt.c:    pNtk->pManName = Abc_NamStart( 1000, 24 );
src/base/wlc/wlcReadSmt.c:    pNtk->fSmtLib = 1;
src/base/wlc/wlcReadSmt.c:        NameId = Abc_NamStrFindOrAdd( pNtk->pManName, pName, NULL );
src/base/wlc/wlcReadSmt.c:        Vec_IntPush( &pNtk->vValues, NameId );
src/base/wlc/wlcReadSmt.c:        Vec_IntPush( &pNtk->vValues, nBits );
src/base/wlc/wlcReadSmt.c:        Vec_IntPush( &pNtk->vValues, Range );
src/base/wlc/wlcReadSmt.c:    Vec_IntAppend( &pNtk->vNameIds, vFans );
src/base/wlc/wlcReadSmt.c:    sprintf(suffix,"_as%d",pNtk->nAssert);
src/base/wlc/wlcReadSmt.c:            fFound =  Abc_NamStrFind( pNtk->pManName, pStr_glb );
src/base/wlc/wlcReadSmt.c:                assert( Abc_NamStrFind( pNtk->pManName, pStr_loc ));
src/base/wlc/wlcReadSmt.c:            iObj = Abc_NamStrFindOrAdd( pNtk->pManName, pStr, &fFound );
src/base/wlc/wlcReadSmt.c:                int iObj = Abc_NamStrFind( pNtk->pManName, pStr0 );
src/base/wlc/wlcReadSmt.c:    pNtk->pManName = Abc_NamStart( 1000, 24 );
src/base/wlc/wlcReadSmt.c:    pNtk->fSmtLib = 1;
src/base/wlc/wlcReadSmt.c:            NameId = Abc_NamStrFindOrAdd( pNtk->pManName, pName, NULL );
src/base/wlc/wlcReadSmt.c:            Vec_IntPush( &pNtk->vValues, NameId );
src/base/wlc/wlcReadSmt.c:            Vec_IntPush( &pNtk->vValues, nBits );
src/base/wlc/wlcReadSmt.c:            Vec_IntPush( &pNtk->vValues, Range );
src/base/wlc/wlcReadSmt.c:            pNtk->nAssert++; // added
src/base/wlc/wlcReadSmt.c:    Vec_IntAppend( &pNtk->vNameIds, vFans );
src/base/wlc/wlcAbc.c:            char c = pObj->Type != WLC_OBJ_FO ? 'i' : pNtk->pInits[nBits + k];
src/base/wlc/wlcAbc.c:    pMainNtk->pName = Extra_UtilStrsav(pNtk ? pNtk->pName : "inv");
src/base/wlc/wlcCom.c:        pFileName = Extra_FileNameGenericAppend( pNtk->pName, "_out.v" );
src/base/wlc/wlcCom.c:    ABC_FREE( pNtk->pName );
src/base/wlc/wlcCom.c:    pNtk->pName = Abc_UtilStrsav( pName );
src/base/wlc/wlcCom.c:    if ( pNtk->fAsyncRst )
src/base/wlc/wlcGraft.c:        iFirst = Vec_IntEntry( &pNtk->vCopies, i );
src/base/wlc/wlcGraft.c:            int iLitGia = Vec_IntEntry( &pNtk->vBits, iFirst + k );
src/base/wlc/wlcGraft.c:    iFirst = Vec_IntEntry( &pNtk->vCopies, Wlc_ObjId(pNtk, pObj) );
src/base/wlc/wlcGraft.c:        int iLitGia  = Vec_IntEntry( &pNtk->vBits, iFirst + k );
src/base/wlc/wlcGraft.c:        iFirst = Vec_IntEntry( &pNtk->vCopies, i );
src/base/wlc/wlcGraft.c:            iLitGia = Vec_IntEntry( &pNtk->vBits, iFirst + k );
src/base/wlc/wlcGraft.c:                iLitGia = Vec_IntEntry( &pNtk->vBits, iFirst + k );
src/base/wlc/wlcReadVer.c:        NameId = Abc_NamStrFindOrAdd( p->pNtk->pManName, Buffer, &fFound );
src/base/wlc/wlcReadVer.c:        NameId = Abc_NamStrFindOrAdd( p->pNtk->pManName, pName, &fFound );
src/base/wlc/wlcReadVer.c:        NameId = Abc_NamStrFindOrAdd( p->pNtk->pManName, pName, &fFound );
src/base/wlc/wlcReadVer.c:            p->pNtk->pManName = Abc_NamStart( Vec_IntSize(p->vStarts), 20 );
src/base/wlc/wlcReadVer.c:            p->pNtk->pMemTable = p->pMemTable; p->pMemTable = NULL;
src/base/wlc/wlcReadVer.c:            p->pNtk->vTables = p->vTables; p->vTables = NULL;
src/base/wlc/wlcReadVer.c:            Vec_IntAppend( &p->pNtk->vNameIds, vTemp );
src/base/wlc/wlcReadVer.c:            if ( p->pNtk->vInits )
src/base/wlc/wlcReadVer.c:                assert( (Vec_IntSize(&p->pNtk->vFfs) & 1) == 0 );
src/base/wlc/wlcReadVer.c:                assert( Vec_IntSize(&p->pNtk->vFfs) == 2 * Vec_IntSize(p->pNtk->vInits) );
src/base/wlc/wlcReadVer.c:                Vec_IntClear( &p->pNtk->vFfs );
src/base/wlc/wlcReadVer.c:                //Vec_IntPrint( p->pNtk->vInits );
src/base/wlc/wlcReadVer.c:                p->pNtk->pInits = Wlc_PrsConvertInitValues( p->pNtk );
src/base/wlc/wlcReadVer.c:                //printf( "%s\n", p->pNtk->pInits );
src/base/wlc/wlcReadVer.c:            if ( p->pNtk->vArsts && !p->pNtk->fAsyncRst )
src/base/wlc/wlcReadVer.c:                Vec_IntForEachEntry( p->pNtk->vArsts, NameIdArst, i )
src/base/wlc/wlcReadVer.c:                    p->pNtk->fAsyncRst = 1;
src/base/wlc/wlcReadVer.c:                    printf( "Detected async reset \"%s\".\n", Abc_NamStr(p->pNtk->pManName, NameIdArst) );
src/base/wlc/wlcReadVer.c:                            Vec_IntPush( &p->pNtk->vPoPairs, i );
src/base/wlc/wlcReadVer.c:                assert( Vec_IntSize(&p->pNtk->vPoPairs) % 2 == 0 );
src/base/wlc/wlcReadVer.c:                printf( "Finished parsing %d output pairs to be checked for equivalence.\n", Vec_IntSize(&p->pNtk->vPoPairs)/2 );
src/base/wlc/wlcReadVer.c:            NameId = Abc_NamStrFindOrAdd( p->pNtk->pManName, pName, &fFound );
src/base/wlc/wlcReadVer.c:            NameId = Abc_NamStrFindOrAdd( p->pNtk->pManName, pName, &fFound );
src/base/wlc/wlcReadVer.c:            NameId = Abc_NamStrFindOrAdd( p->pNtk->pManName, pName, &fFound );
src/base/wlc/wlcReadVer.c:            NameId = Abc_NamStrFindOrAdd( p->pNtk->pManName, pName, &fFound );
src/base/wlc/wlcReadVer.c:                NameIdOut = Abc_NamStrFindOrAdd( p->pNtk->pManName, pName, &fFound );
src/base/wlc/wlcReadVer.c:                if ( !p->pNtk->fAsyncRst && !strncmp(pStart, "arst", 4) && pStart[4] != 'v' )
src/base/wlc/wlcReadVer.c:                        p->pNtk->fAsyncRst = 1;
src/base/wlc/wlcReadVer.c:                    NameIdArst = Abc_NamStrFindOrAdd( p->pNtk->pManName, pName, &fFound );
src/base/wlc/wlcReadVer.c:                    if ( p->pNtk->vArsts == NULL )
src/base/wlc/wlcReadVer.c:                        p->pNtk->vArsts = Vec_IntAlloc( 100 );
src/base/wlc/wlcReadVer.c:                    Vec_IntPushUnique( p->pNtk->vArsts, NameIdArst );
src/base/wlc/wlcReadVer.c:                    NameIdIn = Abc_NamStrFindOrAdd( p->pNtk->pManName, pName, &fFound );
src/base/wlc/wlcReadVer.c:                    NameIdOut = Abc_NamStrFindOrAdd( p->pNtk->pManName, pName, &fFound );
src/base/wlc/wlcReadVer.c:                    NameId = Abc_NamStrFindOrAdd( p->pNtk->pManName, pName, &fFound );
src/base/wlc/wlcReadVer.c:            Vec_IntPush( &p->pNtk->vFfs, NameIdOut );
src/base/wlc/wlcReadVer.c:            //    printf( "Warning!  Flop output \"%s\" has bit-width (%d) that differs from the flop declaration (%d)\n", Abc_NamStr(p->pNtk->pManName, NameIdOut), Wlc_ObjRange(pObj), nBits );
src/base/wlc/wlcReadVer.c:            Vec_IntPush( &p->pNtk->vFfs, NameIdIn );
src/base/wlc/wlcReadVer.c:            //    printf( "Warning!  Flop input \"%s\" has bit-width (%d) that differs from the flop declaration (%d)\n", Abc_NamStr(p->pNtk->pManName, NameIdIn), Wlc_ObjRange(pObj), nBits );
src/base/wlc/wlcReadVer.c:                printf( "Initial value of flop \"%s\" is not specified. Zero is assumed.\n", Abc_NamStr(p->pNtk->pManName, NameIdOut) );
src/base/wlc/wlcReadVer.c:                    printf( "Warning!  Flop init signal \"%s\" bit-width (%d) is different from the flop declaration (%d)\n", Abc_NamStr(p->pNtk->pManName, NameId), Wlc_ObjRange(pObj), nBits );
src/base/wlc/wlcReadVer.c:            if ( p->pNtk->vInits == NULL )
src/base/wlc/wlcReadVer.c:                p->pNtk->vInits = Vec_IntAlloc( 100 );
src/base/wlc/wlcReadVer.c:            Vec_IntPush( p->pNtk->vInits, NameId > 0 ? NameId : -nBits );
src/base/wlc/wlcReadVer.c:            //     Abc_NamStr(p->pNtk->pManName, NameIdOut), Wlc_ObjRange(pObj), nBits, NameId );
src/base/wlc/wlcReadVer.c:                    NameId[0] = Abc_NamStrFindOrAdd( p->pNtk->pManName, pName, &fFound );
src/base/wlc/wlcReadVer.c:                    NameId[1] = Abc_NamStrFindOrAdd( p->pNtk->pManName, pName, &fFound );
src/base/wlc/wlcReadVer.c:                    NameId[2] = Abc_NamStrFindOrAdd( p->pNtk->pManName, pName, &fFound );
src/base/wlc/wlcReadVer.c:                    NameId[3] = Abc_NamStrFindOrAdd( p->pNtk->pManName, pName, &fFound );
src/base/wlc/wlcReadVer.c:                    NameId[4] = Abc_NamStrFindOrAdd( p->pNtk->pManName, pName, &fFound );
src/base/wlc/wlcReadVer.c:                    NameId[5] = Abc_NamStrFindOrAdd( p->pNtk->pManName, pName, &fFound );
src/base/wlc/wlcReadVer.c:                    NameId[6] = Abc_NamStrFindOrAdd( p->pNtk->pManName, pName, &fFound );
src/base/wlc/wlcReadVer.c:                    NameId[7] = Abc_NamStrFindOrAdd( p->pNtk->pManName, pName, &fFound );
src/base/wlc/wlcReadVer.c:                    NameId[8] = Abc_NamStrFindOrAdd( p->pNtk->pManName, pName, &fFound );
src/base/wlc/wlcReadVer.c:                    NameIdIn = Abc_NamStrFindOrAdd( p->pNtk->pManName, pName, &fFound );
src/base/wlc/wlcReadVer.c:                    NameIdOut = Abc_NamStrFindOrAdd( p->pNtk->pManName, pName, &fFound );
src/base/wlc/wlcReadVer.c:                    NameId = Abc_NamStrFindOrAdd( p->pNtk->pManName, pName, &fFound );
src/base/wlc/wlcReadVer.c:            Vec_IntPush( &p->pNtk->vFfs, NameIdOut );
src/base/wlc/wlcReadVer.c:            Vec_IntPush( &p->pNtk->vFfs, NameIdIn );
src/base/wlc/wlcReadVer.c:                    Abc_NamStr(p->pNtk->pManName, NameId), Wlc_ObjRange(Wlc_NtkObj(p->pNtk, NameIdIn)), nBits );
src/base/wlc/wlcReadVer.c:                printf( "Initial value of flop \"%s\" is not specified. Zero is assumed.\n", Abc_NamStr(p->pNtk->pManName, NameIdOut) );
src/base/wlc/wlcReadVer.c:                        Abc_NamStr(p->pNtk->pManName, NameId), Wlc_ObjRange(Wlc_NtkObj(p->pNtk, NameId)), nBits );
src/base/wlc/wlcReadVer.c:            if ( p->pNtk->vInits == NULL )
src/base/wlc/wlcReadVer.c:                p->pNtk->vInits = Vec_IntAlloc( 100 );
src/base/wlc/wlcReadVer.c:            Vec_IntPush( p->pNtk->vInits, NameId > 0 ? NameId : -Wlc_ObjRange(Wlc_NtkObj(p->pNtk, NameIdOut)) );
src/base/wlc/wlcReadVer.c:            //     Abc_NamStr(p->pNtk->pManName, NameIdOut), Wlc_ObjRange(pObj), nBits, NameId );
src/base/wlc/wlcReadVer.c:            p->pNtk->fEasyFfs = 1;
src/base/wlc/wlcReadVer.c:                *pNameId = Abc_NamStrFindOrAdd( p->pNtk->pManName, pName, &fFound );
src/base/wlc/wlcReadVer.c:                *pNameId = Abc_NamStrFindOrAdd( p->pNtk->pManName, pName, &fFound );
src/base/wlc/wlcReadVer.c:            p->pNtk->fMemPorts = 1;
src/base/wlc/wlcReadVer.c:                *pNameId = Abc_NamStrFindOrAdd( p->pNtk->pManName, pName, &fFound );
src/base/wlc/wlcReadVer.c:            p->pNtk->fMemPorts = 1;
src/base/wlc/wlcReadVer.c:                    NameIdInD = Abc_NamStrFindOrAdd( p->pNtk->pManName, pName, &fFound );                                         
src/base/wlc/wlcReadVer.c:                    NameIdInS = Abc_NamStrFindOrAdd( p->pNtk->pManName, pName, &fFound );                                         
src/base/wlc/wlcReadVer.c:                    NameIdOut = Abc_NamStrFindOrAdd( p->pNtk->pManName, pName, &fFound );                                         
src/base/wlc/wlcReadVer.c:                    NameId = Abc_NamStrFindOrAdd( p->pNtk->pManName, pName, &fFound );                                            
src/base/wlc/wlcReadVer.c:                Vec_IntPush( &p->pNtk->vFfs2, Wlc_ObjId(p->pNtk, pObj) );
src/base/wlc/wlcReadVer.c:        pNtk->pSpec = Abc_UtilStrsav( pFileName );
src/base/io/ioWriteBlif.c:    fprintf( pFile, "# Benchmark \"%s\" written by ABC on %s\n", pNtk->pName, Extra_TimeStamp() );
src/base/io/ioWriteBlif.c:        Vec_PtrForEachEntry( Abc_Ntk_t *, pNtk->pDesign->vModules, pNtkTemp, i )
src/base/io/ioWriteBlif.c:    Length = Abc_NtkHasMapping(pNtk)? Mio_LibraryReadGateNameMax((Mio_Library_t *)pNtk->pManFunc) : 0;
src/base/io/ioWriteBlif.c:    if ( pNtk->pManTime == NULL )
src/base/io/ioWriteBlif.c:    if ( pNtk->AndGateDelay != 0.0 )
src/base/io/ioWriteBlif.c:        fprintf( pFile, ".and_gate_delay %g\n", pNtk->AndGateDelay );
src/base/io/ioWriteBlif.c:    fprintf( pFile, "# Benchmark \"%s\" written by ABC on %s\n", pNtk->pName, Extra_TimeStamp() );
src/base/io/ioReadPlaMo.c:    pNtk->pName = Extra_UtilStrsav( pFileName );
src/base/io/ioReadPlaMo.c:    pNtk->pSpec = Extra_UtilStrsav( pFileName );
src/base/io/ioReadPlaMo.c:            pNode->pData = Abc_SopRegister( (Mem_Flex_t *)pNtk->pManFunc, " 0\n" );
src/base/io/ioReadPlaMo.c:        pNode->pData = Abc_SopRegister( (Mem_Flex_t *)pNtk->pManFunc, Vec_StrArray(vSop) );
src/base/io/ioWriteBench.c:    fprintf( pFile, "# Benchmark \"%s\" written by ABC on %s\n", pNtk->pName, Extra_TimeStamp() );
src/base/io/ioWriteBench.c:    fprintf( pFile, "# Benchmark \"%s\" written by ABC on %s\n", pNtk->pName, Extra_TimeStamp() );
src/base/io/ioWriteBench.c:    pTruth = Hop_ManConvertAigToTruth( (Hop_Man_t *)pNode->pNtk->pManFunc, Hop_Regular((Hop_Obj_t *)pNode->pData), nFanins, vTruth, 0 );
src/base/io/ioWriteBench.c:        for ( pName = Nm_ManFindNameById(pNtk->pManName, i); pName && *pName; pName++ )
src/base/io/ioReadVerilog.c:        printf( "The first one (%s) will be used.\n", pNtk->pName );
src/base/io/ioReadVerilog.c:    pNtk->pDesign = pDesign;
src/base/io/ioReadVerilog.c:        pNtk->pDesign = NULL;
src/base/io/ioReadVerilog.c:        pNtk->pSpec = Extra_UtilStrsav( pFileName );
src/base/io/ioReadEqn.c:    pNtk->pName = Extra_FileNameGeneric(Extra_FileReaderGetFileName(p));
src/base/io/ioReadEqn.c:    pNtk->pSpec = Extra_UtilStrsav(Extra_FileReaderGetFileName(p));
src/base/io/ioReadEqn.c:            pNode->pData = Parse_FormulaParserEqn( stdout, pFormula, vVars, (Hop_Man_t *)pNtk->pManFunc );
src/base/io/ioReadDsd.c:            pObj->pData = Abc_SopRegister( (Mem_Flex_t *)pNtk->pManFunc, pSop );
src/base/io/ioReadDsd.c:            pObj->pData = Abc_SopCreateXorSpecial( (Mem_Flex_t *)pNtk->pManFunc, nParts );
src/base/io/ioReadDsd.c:            pObj->pData = Abc_SopCreateAnd( (Mem_Flex_t *)pNtk->pManFunc, nParts, NULL );
src/base/io/ioReadDsd.c:    pNtk->pName = Extra_UtilStrsav( "dsd" );
src/base/io/ioWriteSmv.c:    fprintf( pFile, "-- benchmark \"%s\" written by ABC on %s\n", pNtk->pName, Extra_TimeStamp() );
src/base/io/ioWriteSmv.c:        for ( pName = Nm_ManFindNameById(pNtk->pManName, i); pName && *pName; pName++ )
src/base/io/ioWriteList.c:    fprintf( pFile, "# Adjacency list for sequential AIG \"%s\"\n", pNtk->pName );
src/base/io/ioWriteList.c:    fprintf( pFile, "# CellNet file for network \"%s\" written by ABC on %s\n", pNtk->pName, Extra_TimeStamp() );
src/base/io/ioReadBblif.c:    pNtk->pName = Extra_UtilStrsav( Bbl_ManName(p) );
src/base/io/ioReadBblif.c:            pObjNew->pData = Abc_SopRegister( (Mem_Flex_t *)pNtk->pManFunc, Bbl_ObjSop(p, pObj) );
src/base/io/ioReadBblif.c:    pNtk->pName = Extra_UtilStrsav( Bbl_ManName(p) );
src/base/io/ioReadBblif.c:    Abc_AigCleanup( (Abc_Aig_t *)pNtk->pManFunc );
src/base/io/ioWriteVerilog.c:    fprintf( pFile, "// Benchmark \"%s\" written by ABC on %s\n", pNtk->pName, Extra_TimeStamp() );
src/base/io/ioWriteVerilog.c:    if ( pNtk->pDesign )
src/base/io/ioWriteVerilog.c:        Vec_PtrForEachEntry( Abc_Ntk_t *, pNtk->pDesign->vModules, pNetlist, i )
src/base/io/ioWriteVerilog.c:    if ( Abc_NtkLatchNum(pNtk) > 0 && Nm_ManFindIdByName(pNtk->pManName, "clock", ABC_OBJ_PI) == -1 )
src/base/io/ioWriteVerilog.c:    if ( Abc_NtkLatchNum(pNtk) > 0 && Nm_ManFindIdByName(pNtk->pManName, "clock", ABC_OBJ_PI) == -1 )
src/base/io/ioWriteVerilog.c:        Length  = Mio_LibraryReadGateNameMax((Mio_Library_t *)pNtk->pManFunc);
src/base/io/ioWriteVerilog.c:                Hop_IthVar((Hop_Man_t *)pNtk->pManFunc, k)->pData = Extra_UtilStrsav(Io_WriteVerilogGetName(Abc_ObjName(pFanin)));
src/base/io/ioWriteVerilog.c:                ABC_FREE( Hop_IthVar((Hop_Man_t *)pNtk->pManFunc, k)->pData );
src/base/io/ioWriteVerilog.c:    if ( Abc_NtkLatchNum(pNtk) > 0 && Nm_ManFindIdByName(pNtk->pManName, "clock", ABC_OBJ_PI) == -1 )
src/base/io/ioWriteVerilog.c:    if ( Abc_NtkLatchNum(pNtk) > 0 && Nm_ManFindIdByName(pNtk->pManName, "clock", ABC_OBJ_PI) == -1 )
src/base/io/ioWriteVerilog.c:    fprintf( pFile, "// Benchmark \"%s\" written by ABC on %s\n", pNtk->pName, Extra_TimeStamp() );
src/base/io/ioWriteEqn.c:    fprintf( pFile, "# Equations for \"%s\" written by ABC on %s\n", pNtk->pName, Extra_TimeStamp() );
src/base/io/ioWriteEqn.c:            Hop_IthVar((Hop_Man_t *)pNtk->pManFunc, k)->pData = Io_NamePrepro( Abc_ObjName(pFanin) );
src/base/io/ioWriteEqn.c:        pName = Nm_ManFindNameById(pNtk->pManName, i);
src/base/io/ioReadBlif.c:    pNtk->pSpec = Extra_UtilStrsav( pFileName );
src/base/io/ioReadBlif.c:            pNtk->pExdc = Io_ReadBlifNetworkOne( p );
src/base/io/ioReadBlif.c:            if ( pNtk->pExdc == NULL )
src/base/io/ioReadBlif.c:            Abc_NtkFinalizeRead( pNtk->pExdc );
src/base/io/ioReadBlif.c:        if ( pNtkMaster->tName2Model && stmm_is_member( pNtkMaster->tName2Model, pNtk->pName ) )
src/base/io/ioReadBlif.c:            sprintf( p->sError, "Model %s is multiply defined in the file.", pNtk->pName );
src/base/io/ioReadBlif.c:        stmm_insert( pNtkMaster->tName2Model, pNtk->pName, (char *)pNtk );
src/base/io/ioReadBlif.c:        pNtk->pName = Extra_UtilStrsav( pPivot );
src/base/io/ioReadBlif.c:            pNtk->ntkType = ABC_NTK_NETLIST;
src/base/io/ioReadBlif.c:            pNtk->ntkFunc = ABC_FUNC_BLACKBOX;
src/base/io/ioReadBlif.c:            Mem_FlexStop( (Mem_Flex_t *)pNtk->pManFunc, 0 );
src/base/io/ioReadBlif.c:            pNtk->pManFunc = NULL;
src/base/io/ioReadBlif.c:    Abc_ObjSetData( pNode, Abc_SopRegister((Mem_Flex_t *)pNtk->pManFunc, p->vCubes->pArray) );
src/base/io/ioWritePla.c:    fprintf( pFile, "# Benchmark \"%s\" written by ABC on %s\n", pNtk->pName, Extra_TimeStamp() );
src/base/io/ioWritePla.c:    fprintf( pFile, "# Benchmark \"%s\" written by ABC on %s\n", pNtk->pName, Extra_TimeStamp() );
src/base/io/ioWritePla.c:        dd = (DdManager *)pNtk->pManFunc;
src/base/io/ioWritePla.c:    fprintf( pFile, "# Benchmark \"%s\" written by ABC on %s\n", pNtk->pName, Extra_TimeStamp() );
src/base/io/ioReadPla.c:            ABC_FREE( pNtk->pName );
src/base/io/ioReadPla.c:            pNtk->pName = Extra_UtilStrsav( (char *)vTokens->pArray[1] );
src/base/io/ioReadPla.c:            pNode->pData = Abc_SopRegister( (Mem_Flex_t *)pNtk->pManFunc, " 0\n" );
src/base/io/ioReadPla.c:        pNode->pData = Abc_SopRegister( (Mem_Flex_t *)pNtk->pManFunc, ppSops[i]->pArray );
src/base/io/ioWriteDot.c:    fprintf( pFile, "Benchmark \\\"%s\\\". ", pNtk->pName );
src/base/io/ioWriteDot.c:    fprintf( pFile, "Benchmark \\\"%s\\\". ", pNtk->pName );
src/base/io/ioWriteBlifMv.c:    fprintf( pFile, "# Benchmark \"%s\" written by ABC on %s\n", pNtk->pName, Extra_TimeStamp() );
src/base/io/ioWriteBlifMv.c:    if ( pNtk->pDesign )
src/base/io/ioWriteBlifMv.c:        Vec_PtrForEachEntry( Abc_Ntk_t *, pNtk->pDesign->vModules, pNtkTemp, i )
src/base/io/ioWriteAiger.c:    if ( pNtk->pName && strlen(pNtk->pName) > 0 )
src/base/io/ioWriteAiger.c:        fprintf( pFile, ".model %s\n", pNtk->pName );
src/base/io/ioWriteAiger.c:    if ( pNtk->pName && strlen(pNtk->pName) > 0 )
src/base/io/ioWriteAiger.c:        gzprintf( pFile, ".model %s\n", pNtk->pName );
src/base/io/ioWriteAiger.c:        if ( pNtk->pName && strlen(pNtk->pName) > 0 )
src/base/io/ioWriteAiger.c:            fprintfBz2Aig( &b, "\n%s%c", pNtk->pName, '\0' );
src/base/io/ioUtil.c:    if ( fCheck && (Abc_NtkBlackboxNum(pNtk) || Abc_NtkWhiteboxNum(pNtk)) && pNtk->pDesign )
src/base/io/ioUtil.c:        Vec_PtrForEachEntry( Abc_Ntk_t *, pNtk->pDesign->vModules, pModel, i )
src/base/io/ioUtil.c:    if( pNtk && Vec_PtrSize( pNtk->vLtlProperties ) > 0 )
src/base/io/ioUtil.c:        tempStore = Vec_PtrAlloc( Vec_PtrSize( pNtk->vLtlProperties ) );
src/base/io/ioUtil.c:        Vec_PtrForEachEntry( char *, pNtk->vLtlProperties, pFormula, i )
src/base/io/ioUtil.c:        assert( Vec_PtrSize( tempStore ) == Vec_PtrSize( pNtk->vLtlProperties ) );
src/base/io/ioUtil.c:        Vec_PtrPush( pNtk->vLtlProperties, pFormula );
src/base/io/ioUtil.c:    if ( Abc_NtkWhiteboxNum(pNtkBase) > 0 && pNtk->nBarBufs == 0 )
src/base/io/ioUtil.c:    if ( pNtk->nBarBufs > 0 )
src/base/io/ioUtil.c:            printf( "Hierarchy writer replaced %d barbufs by hierarchy boundaries.\n", pNtk->nBarBufs );
src/base/io/ioUtil.c://    pNode->pData = Abc_SopRegister( (Extra_MmFlex_t *)pNtk->pManFunc, "2\n1\n" );
src/base/io/ioWriteEdgelist.c:    fprintf( pFile, "# Benchmark Edgelist Dumping (beta) \"%s\" written by ABC on %s (more at https://github.com/ycunxi/Verilog-to-PyG)\n", pNtk->pName, Extra_TimeStamp() );
src/base/io/ioWriteEdgelist.c:        Vec_PtrForEachEntry( Abc_Ntk_t *, pNtk->pDesign->vModules, pNtkTemp, i )
src/base/io/ioWriteEdgelist.c:    Length = Abc_NtkHasMapping(pNtk)? Mio_LibraryReadGateNameMax((Mio_Library_t *)pNtk->pManFunc) : 0;
src/base/io/io.c:    Vec_IntFreeP( &pNtk->vFins );
src/base/io/io.c:    pNtk->vFins = Io_ReadFins( pNtk, pFileName, fVerbose );
src/base/io/io.c:    else if ( pNtk->pSpec )
src/base/io/io.c:        pFileName = Extra_FileNameGenericAppend( pNtk->pSpec, ".init" );
src/base/io/io.c:    ABC_FREE( pNtk->pName );
src/base/io/io.c:    pNtk->pName = Extra_FileNameGeneric( pFileName );
src/base/io/io.c:    ABC_FREE( pNtk->pSpec );
src/base/io/io.c:    pNtk->pSpec = Abc_UtilStrsav( pFileName );
src/base/io/io.c:    if ( pNtk->pModel == NULL && pAbc->pCex == NULL && pAbc->vCexVec == NULL )
src/base/io/io.c://                fprintf( pFile, "%s=%c\n", Abc_ObjName(pObj), '0'+(pNtk->pModel[i]==1) );
src/base/io/io.c:                fprintf( pFile, "%s%s=%c\n", Abc_ObjName(pObj), cycle_ctr, '0'+(pNtk->pModel[i]==1) );
src/base/io/io.c:                fprintf( pFile, "%c", '0'+(pNtk->pModel[i]==1) );
src/base/io/io.c:    pTruth = Hop_ManConvertAigToTruth( (Hop_Man_t *)pNtk->pManFunc, (Hop_Obj_t *)pNode->pData, Abc_ObjFaninNum(pNode), vTruth, fReverse );
src/base/io/ioReadBench.c:    pNtk->nConstrs = 0;
src/base/io/ioReadBench.c:                    pNtk->nConstrs++;
src/base/io/ioReadBench.c:                    Abc_ObjSetData( pNode, Abc_SopRegister( (Mem_Flex_t *)pNtk->pManFunc, " 0\n" ) );
src/base/io/ioReadBench.c:                    Abc_ObjSetData( pNode, Abc_SopRegister( (Mem_Flex_t *)pNtk->pManFunc, " 1\n" ) );
src/base/io/ioReadBench.c:                        Abc_ObjSetData( pNode, Abc_SopCreateFromTruth((Mem_Flex_t *)pNtk->pManFunc, nNames, uTruth) );
src/base/io/ioReadBench.c:                        Abc_ObjSetData( pNode, Abc_SopCreateBuf((Mem_Flex_t *)pNtk->pManFunc) );
src/base/io/ioReadBench.c:                        Abc_ObjSetData( pNode, Abc_SopCreateInv((Mem_Flex_t *)pNtk->pManFunc) );
src/base/io/ioReadBench.c:                    Abc_ObjSetData( pNode, Abc_SopCreateAnd((Mem_Flex_t *)pNtk->pManFunc, nNames, NULL) );
src/base/io/ioReadBench.c:                    Abc_ObjSetData( pNode, Abc_SopCreateOr((Mem_Flex_t *)pNtk->pManFunc, nNames, NULL) );
src/base/io/ioReadBench.c:                    Abc_ObjSetData( pNode, Abc_SopCreateNand((Mem_Flex_t *)pNtk->pManFunc, nNames) );
src/base/io/ioReadBench.c:                    Abc_ObjSetData( pNode, Abc_SopCreateNor((Mem_Flex_t *)pNtk->pManFunc, nNames) );
src/base/io/ioReadBench.c:                    Abc_ObjSetData( pNode, Abc_SopCreateXor((Mem_Flex_t *)pNtk->pManFunc, nNames) );
src/base/io/ioReadBench.c:                    Abc_ObjSetData( pNode, Abc_SopCreateNxor((Mem_Flex_t *)pNtk->pManFunc, nNames) );
src/base/io/ioReadBench.c:                    Abc_ObjSetData( pNode, Abc_SopCreateBuf((Mem_Flex_t *)pNtk->pManFunc) );
src/base/io/ioReadBench.c:                    Abc_ObjSetData( pNode, Abc_SopCreateInv((Mem_Flex_t *)pNtk->pManFunc) );
src/base/io/ioReadBench.c://                    Abc_ObjSetData( pNode, Abc_SopRegister(pNtk->pManFunc, "1-0 1\n-11 1\n") );
src/base/io/ioReadBench.c:                    Abc_ObjSetData( pNode, Abc_SopRegister((Mem_Flex_t *)pNtk->pManFunc, "0-1 1\n11- 1\n") );
src/base/io/ioReadBench.c:                    Abc_ObjSetData( pNode, Abc_SopRegister( (Mem_Flex_t *)pNtk->pManFunc, " 0\n" ) );
src/base/io/ioReadBench.c:                    Abc_ObjSetData( pNode, Abc_SopRegister( (Mem_Flex_t *)pNtk->pManFunc, " 1\n" ) );
src/base/io/ioReadBench.c:        Num = Nm_ManFindIdByName( pNtk->pManName, pToken, ABC_OBJ_BO );
src/base/io/ioWriteGml.c:    fprintf( pFile, "# GML for \"%s\" written by ABC on %s\n", pNtk->pName, Extra_TimeStamp() );
src/base/io/ioWriteBaf.c:    fprintf( pFile, "# BAF (Binary Aig Format) for \"%s\" written by ABC on %s\n", pNtk->pName, Extra_TimeStamp() );
src/base/io/ioWriteBaf.c:    fprintf( pFile, "%s%c", pNtk->pName, 0 );
src/base/io/ioWriteBook.c:        Vec_PtrForEachEntry( Abc_Ntk_t *, pNtk->pDesign->vModules, pNtkTemp, i )
src/base/io/ioReadEdif.c:            ABC_FREE( pNtk->pName ); 
src/base/io/ioReadEdif.c:            pNtk->pName = (char *)Extra_UtilStrsav( (char *)vTokens->pArray[3] );
src/base/io/ioReadEdif.c:            Abc_ObjSetData( pObj, Abc_SopCreateAnd((Mem_Flex_t *)pNtk->pManFunc, Abc_ObjFaninNum(pObj), NULL) );
src/base/io/ioReadEdif.c:            Abc_ObjSetData( pObj, Abc_SopCreateOr((Mem_Flex_t *)pNtk->pManFunc, Abc_ObjFaninNum(pObj), NULL) );
src/base/io/ioReadEdif.c:            Abc_ObjSetData( pObj, Abc_SopCreateNand((Mem_Flex_t *)pNtk->pManFunc, Abc_ObjFaninNum(pObj)) );
src/base/io/ioReadEdif.c:            Abc_ObjSetData( pObj, Abc_SopCreateNor((Mem_Flex_t *)pNtk->pManFunc, Abc_ObjFaninNum(pObj)) );
src/base/io/ioReadEdif.c:            Abc_ObjSetData( pObj, Abc_SopCreateXor((Mem_Flex_t *)pNtk->pManFunc, Abc_ObjFaninNum(pObj)) );
src/base/io/ioReadEdif.c:            Abc_ObjSetData( pObj, Abc_SopCreateNxor((Mem_Flex_t *)pNtk->pManFunc, Abc_ObjFaninNum(pObj)) );
src/base/io/ioReadEdif.c:            Abc_ObjSetData( pObj, Abc_SopCreateInv((Mem_Flex_t *)pNtk->pManFunc) );
src/base/io/ioReadEdif.c:            Abc_ObjSetData( pObj, Abc_SopCreateBuf((Mem_Flex_t *)pNtk->pManFunc) );
src/base/io/ioReadBlifMv.c:                printf( "Io_ReadBlifMv: The network check has failed for model %s.\n", pNtk->pName );
src/base/io/ioReadBlifMv.c:                assert( pNtk->pExdc == NULL );
src/base/io/ioReadBlifMv.c:                pNtk->pExdc = pExdc;
src/base/io/ioReadBlifMv.c:            Vec_PtrSize(pDesign->vTops), pNtk->pName );
src/base/io/ioReadBlifMv.c:    pNtk->pDesign = pDesign;
src/base/io/ioReadBlifMv.c:        pNtk->pDesign = NULL;
src/base/io/ioReadBlifMv.c:        pNtk->pSpec = Extra_UtilStrsav( pFileName );
src/base/io/ioReadBlifMv.c:    if ( pNtk->pSpec == NULL )
src/base/io/ioReadBlifMv.c:        pNtk->pSpec = Extra_UtilStrsav( pFileName );
src/base/io/ioReadBlifMv.c:        Vec_PtrPush( pNtk->vLtlProperties, pLtlProp );
src/base/io/ioReadBlifMv.c:        pMod->pNtk->nConstrs = Abc_NtkPoNum(pMod->pNtk) - nOutsOld;
src/base/io/ioReadBlifMv.c:                pMod->pNtk->pName, Abc_NtkPiNum(pMod->pNtk), Abc_NtkPoNum(pMod->pNtk),
src/base/io/ioReadBlifMv.c:            printf( "Parsing model %s...\n", pMod->pNtk->pName );
src/base/io/ioReadBlifMv.c:            if ( pMod->pNtk->ntkFunc == ABC_FUNC_SOP )
src/base/io/ioReadBlifMv.c:                Mem_FlexStop( (Mem_Flex_t *)pMod->pNtk->pManFunc, 0 );
src/base/io/ioReadBlifMv.c:                pMod->pNtk->pManFunc = NULL;
src/base/io/ioReadBlifMv.c:                pMod->pNtk->ntkFunc = ABC_FUNC_BLACKBOX;
src/base/io/ioReadBlifMv.c:            pMod->pNtk->vOnehots = Vec_PtrAlloc( Vec_PtrSize(pMod->vOnehots) );
src/base/io/ioReadBlifMv.c:                Vec_PtrPush( pMod->pNtk->vOnehots, vLine );
src/base/io/ioReadBlifMv.c:            printf( "Parsed %d groups of 1-hot registers: { ", Vec_PtrSize(pMod->pNtk->vOnehots) );
src/base/io/ioReadBlifMv.c:            Vec_PtrForEachEntry( Vec_Int_t *, pMod->pNtk->vOnehots, vLine, k )
src/base/io/ioReadBlifMv.c:                Vec_VecSizeSize( (Vec_Vec_t *)pMod->pNtk->vOnehots ), 
src/base/io/ioReadBlifMv.c:                100.0 * Vec_VecSizeSize( (Vec_Vec_t *)pMod->pNtk->vOnehots ) / Abc_NtkLatchNum(pMod->pNtk) );
src/base/io/ioReadBlifMv.c:                Abc_GenOneHotIntervals( pFileName, Abc_NtkPiNum(pMod->pNtk), Abc_NtkLatchNum(pMod->pNtk), pMod->pNtk->vOnehots );
src/base/io/ioReadBlifMv.c:        p->pNtk->pName = Extra_UtilStrsav( "EXDC" );
src/base/io/ioReadBlifMv.c:    p->pNtk->pName = Extra_UtilStrsav( pPivot );
src/base/io/ioReadBlifMv.c:            //pNode->pData = Abc_SopRegister( (Mem_Flex_t *)p->pNtk->pManFunc, " 0\n" );
src/base/io/ioReadBlifMv.c:        pNode->pData = Abc_SopRegister( (Mem_Flex_t *)p->pNtk->pManFunc, Buffer );
src/base/io/ioReadBlifMv.c:        pNode->pData = Abc_SopCreateMux( (Mem_Flex_t *)p->pNtk->pManFunc );
src/base/io/ioReadBlifMv.c:    pNode->pData = Abc_SopRegister( (Mem_Flex_t *)p->pNtk->pManFunc, (char *)pNode->pData );
src/base/io/ioReadBlifMv.c:        return Abc_SopCreateConst0( (Mem_Flex_t *)p->pNtk->pManFunc );
src/base/io/ioReadBlifMv.c:        return pOutput[0] == '0' ? Abc_SopCreateConst0((Mem_Flex_t *)p->pNtk->pManFunc) : Abc_SopCreateConst1((Mem_Flex_t *)p->pNtk->pManFunc);
src/base/io/ioReadBlifMv.c:    pNode->pData = Abc_SopRegister( (Mem_Flex_t *)p->pNtk->pManFunc, (char *)pNode->pData );
src/base/io/ioReadBlifMv.c:    if ( p->pNtk->ntkFunc == ABC_FUNC_MAP )
src/base/io/ioReadBlifMv.c:        pNode->pData = Abc_SopRegister( (Mem_Flex_t *)p->pNtk->pManFunc, "1 1\n" );
src/base/io/ioReadBlifMv.c:    if ( Abc_NtkNodeNum(p->pNtk) == 0 && p->pNtk->ntkFunc == ABC_FUNC_SOP )
src/base/io/ioReadBlifMv.c:        assert( p->pNtk->ntkFunc == ABC_FUNC_SOP );
src/base/io/ioReadBlifMv.c:        p->pNtk->ntkFunc = ABC_FUNC_MAP;
src/base/io/ioReadBlifMv.c:        Mem_FlexStop( (Mem_Flex_t *)p->pNtk->pManFunc, 0 );
src/base/io/ioReadBlifMv.c:        p->pNtk->pManFunc = pGenlib;
src/base/abc/abcBlifMv.c:    Vec_PtrWriteEntry( pNtk->vAttrs, VEC_ATTR_MVVAR, pAttMan );
src/base/abc/abcBlifMv.c:    pNtkNew->pName = Extra_UtilStrsav( pNtk->pName );
src/base/abc/abcBlifMv.c://    pNtkNew->pSpec = Extra_UtilStrsav( pNtk->pName );
src/base/abc/abcBlifMv.c:    pNtkNew = Abc_NtkAlloc( pNtk->ntkType, pNtk->ntkFunc, 1 );
src/base/abc/abcBlifMv.c:    pNtkNew->pName = Extra_UtilStrsav( pNtk->pName );
src/base/abc/abcBlifMv.c:    pNtkNew->pSpec = Extra_UtilStrsav( pNtk->pName );
src/base/abc/abcBlifMv.c:        Cudd_RecursiveDeref( (DdManager *)pNtk->pManFunc, (DdNode *)pNode->pData );
src/base/abc/abcBlifMv.c:    pNtk->ntkFunc = ABC_FUNC_BLIFMV;
src/base/abc/abcBlifMv.c:    Cudd_Quit( (DdManager *)pNtk->pManFunc );
src/base/abc/abcBlifMv.c:    pNtk->pManFunc = pMmFlex;
src/base/abc/abcUtil.c:    pAttrMan = (Vec_Att_t *)Vec_PtrEntry( pNtk->vAttrs, Attr );
src/base/abc/abcUtil.c:    Vec_PtrWriteEntry( pNtk->vAttrs, Attr, NULL );
src/base/abc/abcUtil.c:    Vec_PtrClear( pNtk->vCis );
src/base/abc/abcUtil.c:    Vec_PtrClear( pNtk->vCos );
src/base/abc/abcUtil.c:        Vec_PtrPush( pNtk->vCis, pObj );
src/base/abc/abcUtil.c:        Vec_PtrPush( pNtk->vCos, pObj );
src/base/abc/abcUtil.c:            Vec_PtrPush( pNtk->vCos, pTerm );
src/base/abc/abcUtil.c:            Vec_PtrPush( pNtk->vCis, pTerm );
src/base/abc/abcUtil.c:            Vec_PtrPush( pNtk->vCos, pTerm );
src/base/abc/abcUtil.c:            Vec_PtrPush( pNtk->vCis, pTerm );
src/base/abc/abcUtil.c:    DdManager * dd = (DdManager *)pNtk->pManFunc;
src/base/abc/abcUtil.c:        if ( pNtk->pSpec == NULL )
src/base/abc/abcUtil.c:        pFile = fopen( pNtk->pSpec, "r" );
src/base/abc/abcUtil.c:            fprintf( pErr, "Cannot open the external spec file \"%s\".\n", pNtk->pSpec );
src/base/abc/abcUtil.c:        pNtk2 = Io_Read( pNtk->pSpec, Io_ReadFileType(pNtk->pSpec), fCheck, 0 );
src/base/abc/abcUtil.c:    vObjsNew = Vec_PtrAlloc( pNtk->nObjs );
src/base/abc/abcUtil.c:    assert( Vec_PtrSize(vObjsNew) == pNtk->nObjs );
src/base/abc/abcUtil.c:    Vec_PtrFree( pNtk->vObjs );
src/base/abc/abcUtil.c:    pNtk->vObjs = vObjsNew;
src/base/abc/abcUtil.c:    Abc_AigRehash( (Abc_Aig_t *)pNtk->pManFunc );
src/base/abc/abcUtil.c:static inline int  Abc_NtkTopoHasBeg( Abc_Obj_t * p )  { return Vec_IntEntry(p->pNtk->vTopo, 2*Abc_ObjId(p)  );       }
src/base/abc/abcUtil.c:static inline int  Abc_NtkTopoHasEnd( Abc_Obj_t * p )  { return Vec_IntEntry(p->pNtk->vTopo, 2*Abc_ObjId(p)+1);       }
src/base/abc/abcUtil.c:static inline void Abc_NtkTopoSetBeg( Abc_Obj_t * p )  { Vec_IntWriteEntry(p->pNtk->vTopo, 2*Abc_ObjId(p)  , Vec_IntSize(p->pNtk->vTopo));  }
src/base/abc/abcUtil.c:static inline void Abc_NtkTopoSetEnd( Abc_Obj_t * p )  { Vec_IntWriteEntry(p->pNtk->vTopo, 2*Abc_ObjId(p)+1, Vec_IntSize(p->pNtk->vTopo));  }
src/base/abc/abcUtil.c:        Vec_IntPush( pObj->pNtk->vTopo, Abc_ObjId(pObj) );
src/base/abc/abcUtil.c:    Vec_IntPush( pObj->pNtk->vTopo, Abc_ObjId(pObj) );
src/base/abc/abcUtil.c:    pNtkNew = Abc_NtkStartFrom( pNtk, pNtk->ntkType, pNtk->ntkFunc );
src/base/abc/abcUtil.c:    pNtk->pCopy = pNtkNew;
src/base/abc/abcUtil.c:    assert( pNtk->vPhases != NULL );
src/base/abc/abcUtil.c:    assert( Vec_IntSize(pNtk->vPhases) == Abc_NtkObjNumMax(pNtk) );
src/base/abc/abcUtil.c:            Vec_IntWriteEntry( pNtkNew->vPhases, Abc_ObjId( (Abc_Obj_t *)pObj->pCopy ), Vec_IntEntry(pNtk->vPhases, i) );
src/base/abc/abcUtil.c:    pNtkNew = Abc_NtkAlloc( pNtk->ntkType, pNtk->ntkFunc, 1 );
src/base/abc/abcUtil.c:    pNtkNew->pName = Extra_UtilStrsav(pNtk->pName);
src/base/abc/abcUtil.c:    pNtkNew->pSpec = Extra_UtilStrsav(pNtk->pSpec);
src/base/abc/abcUtil.c:    pNew->pName = Abc_UtilStrsav( pNtk->pName );
src/base/abc/abcUtil.c:    pNew->pSpec = Abc_UtilStrsav( pNtk->pSpec );
src/base/abc/abcHieGia.c:    Hop_Man_t * pMan = (Hop_Man_t *)pNode->pNtk->pManFunc;
src/base/abc/abcHieGia.c:    Vec_Ptr_t * vDfs = (Vec_Ptr_t *)pNtk->pData;
src/base/abc/abcHieGia.c:    pNew->pName = Abc_UtilStrsav(pNtk->pName);
src/base/abc/abcHieGia.c:    pNew->pSpec = Abc_UtilStrsav(pNtk->pSpec);
src/base/abc/abcHieGia.c:    if ( !pNtk->pDesign )
src/base/abc/abcHieGia.c:        pNtk->pData = Abc_NtkDfsWithBoxes( pNtk );
src/base/abc/abcHieGia.c:        Vec_PtrForEachEntry( Abc_Ntk_t *, pNtk->pDesign->vModules, pModel, i )
src/base/abc/abcHieGia.c:    if ( !pNtk->pDesign )
src/base/abc/abcHieGia.c:        Vec_PtrFreeP( (Vec_Ptr_t **)&pNtk->pData );
src/base/abc/abcHieGia.c:        Vec_PtrForEachEntry( Abc_Ntk_t *, pNtk->pDesign->vModules, pModel, i )
src/base/abc/abcHieGia.c:    if ( !pNtk->pDesign )
src/base/abc/abcHieGia.c:        Vec_PtrForEachEntry( Abc_Ntk_t *, pNtk->pDesign->vModules, pModel, i )
src/base/abc/abcHieGia.c:    pNew->pName = Abc_UtilStrsav(pNtk->pName);
src/base/abc/abcHieGia.c:    pNew->pSpec = Abc_UtilStrsav(pNtk->pSpec);
src/base/abc/abcHieGia.c:        pNtk->pDesign ? Vec_PtrSize(pNtk->pDesign->vModules)-1 : 0, Vec_PtrSize(vBuffers), Counter );
src/base/abc/abcHieGia.c:    pNtk->pManFunc = pNew->pManFunc;
src/base/abc/abcHieGia.c:    pNtk->ntkFunc  = pNew->ntkFunc;
src/base/abc/abcHieGia.c:    if ( !pNtk->pDesign )
src/base/abc/abcHieGia.c:        Vec_PtrForEachEntry( Abc_Ntk_t *, pNtk->pDesign->vModules, pModel, i )
src/base/abc/abcHieGia.c:    if ( pNtk->pDesign )
src/base/abc/abcHieGia.c:        Vec_PtrForEachEntry( Abc_Ntk_t *, pNtk->pDesign->vModules, pModel, i )
src/base/abc/abcFanio.c:    Vec_IntPushMem( pObj->pNtk->pMmStep, &pObj->vFanins,     pFaninR->Id );
src/base/abc/abcFanio.c:    Vec_IntPushMem( pObj->pNtk->pMmStep, &pFaninR->vFanouts, pObj->Id    );
src/base/abc/abcFanio.c:    Vec_IntPushMem( pObj->pNtk->pMmStep, &pFaninNewR->vFanouts, pObj->Id );
src/base/abc/abcFanio.c:    Vec_IntPushMem( pNodeNew->pNtk->pMmStep, &pNodeNew->vFanins,  pNodeIn->Id  );
src/base/abc/abcFanio.c:    Vec_IntPushMem( pNodeNew->pNtk->pMmStep, &pNodeNew->vFanouts, pNodeOut->Id );
src/base/abc/abcHieCec.c:    Vec_Ptr_t * vOrder = (Vec_Ptr_t *)pNtk->pData;
src/base/abc/abcHieCec.c:    if ( pNtk->pData != NULL )
src/base/abc/abcHieCec.c:    pNtk->pData = Abc_NtkDeriveFlatGia2Derive( pNtk, vOrder );
src/base/abc/abcHieCec.c:    vMods = pNtk->pDesign->vModules;
src/base/abc/abcHieCec.c:    pGia = pNtk->pData;  pNtk->pData = NULL;
src/base/abc/abcHieCec.c:    if ( pNtk->iStep >= 0 )
src/base/abc/abcHieCec.c:    pNtk->iStep = Vec_PtrSize(vModels);
src/base/abc/abcHieCec.c:    if ( pNtk->pDesign == NULL )
src/base/abc/abcHieCec.c:    vMods = pNtk->pDesign->vModules;
src/base/abc/abcHieCec.c:    if ( pNtk->iStep >= 0 )
src/base/abc/abcHieCec.c:        return pNtk->iStep;
src/base/abc/abcHieCec.c:    return pNtk->iStep = 1 + Counter;
src/base/abc/abcHieCec.c:    if ( pNtk->pDesign == NULL )
src/base/abc/abcHieCec.c:        vMods = pNtk->pDesign->vModules;
src/base/abc/abcHieCec.c:    if ( pNtk->dTemp >= 0 )
src/base/abc/abcHieCec.c:        return pNtk->dTemp;
src/base/abc/abcHieCec.c:    return pNtk->dTemp = Counter;
src/base/abc/abcHieCec.c:    if ( pNtk->pDesign == NULL )
src/base/abc/abcHieCec.c:        vMods = pNtk->pDesign->vModules;
src/base/abc/abcHieCec.c:    if ( pNtk->pDesign == NULL )
src/base/abc/abcHieCec.c:    vMods = pNtk->pDesign->vModules;
src/base/abc/abcHieCec.c:    if ( pNtk->pDesign == NULL || pNtk->pDesign->vModules == NULL )
src/base/abc/abcHieCec.c:    if ( pNtk->pDesign != NULL )
src/base/abc/abcHieCec.c:        vMods = pNtk->pDesign->vModules;
src/base/abc/abcBarBuf.c:    if ( pNtk->pDesign == NULL )
src/base/abc/abcBarBuf.c:    Vec_PtrForEachEntry( Abc_Ntk_t *, pNtk->pDesign->vModules, pTemp, i )
src/base/abc/abcBarBuf.c:    Vec_PtrForEachEntry( Abc_Ntk_t *, pNtk->pDesign->vModules, pTemp, i )
src/base/abc/abcBarBuf.c:    Vec_PtrForEachEntry( Abc_Ntk_t *, pNtk->pDesign->vModules, pTemp, i )
src/base/abc/abcBarBuf.c:    assert( pNtk->pDesign != NULL );
src/base/abc/abcBarBuf.c:    pNtkNew = Abc_NtkAlloc( ABC_NTK_LOGIC, pNtk->ntkFunc, 1 );
src/base/abc/abcBarBuf.c:    pNtkNew->pName = Extra_UtilStrsav(pNtk->pName);
src/base/abc/abcBarBuf.c:    pNtkNew->pSpec = Extra_UtilStrsav(pNtk->pSpec);
src/base/abc/abcBarBuf.c:    Vec_PtrForEachEntry( Abc_Ntk_t *, pNtk->pDesign->vModules, pTemp, i )
src/base/abc/abcBarBuf.c:    assert( Abc_NtkLatchNum(pNtk) == pNtk->nBarBufs );
src/base/abc/abcBarBuf.c:        pTemp->pCopy = Abc_NtkStartFrom( pTemp, pNtk->ntkType, pNtk->ntkFunc );
src/base/abc/abcBarBuf.c:        Nm_ManStoreIdName( pObj->pCopy->pNtk->pManName, Abc_ObjFanout0(pObj->pCopy)->Id, Abc_ObjFanout0(pObj->pCopy)->Type, Abc_ObjName(Abc_ObjFanout0(pObj)), NULL );
src/base/abc/abcBarBuf.c:        Nm_ManStoreIdName( pObj->pCopy->pNtk->pManName, Abc_ObjFanin0(pObj->pCopy)->Id, Abc_ObjFanin0(pObj->pCopy)->Type, Abc_ObjName(Abc_ObjFanin0(pObj)), NULL );
src/base/abc/abcBarBuf.c:    assert( pNtk->nBarBufs > 0 );
src/base/abc/abcBarBuf.c:    assert( pNtk->nBarBufs == Abc_NtkLatchNum(pNtk) );
src/base/abc/abcBarBuf.c:        if ( i >= Abc_NtkCiNum(pNtk) - pNtk->nBarBufs )
src/base/abc/abcBarBuf.c:        if ( i < Abc_NtkCoNum(pNtk) - pNtk->nBarBufs )
src/base/abc/abcBarBuf.c:        if ( i >= Abc_NtkCoNum(pNtk) - pNtk->nBarBufs )
src/base/abc/abcBarBuf.c:    assert( pNtk->pDesign == NULL );
src/base/abc/abcBarBuf.c:    assert( pNtk->nBarBufs > 0 );
src/base/abc/abcBarBuf.c:    assert( pNtk->nBarBufs == Abc_NtkLatchNum(pNtk) );
src/base/abc/abcBarBuf.c:    pNtkNew = Abc_NtkAlloc( ABC_NTK_LOGIC, pNtk->ntkFunc, 1 );
src/base/abc/abcBarBuf.c:    pNtkNew->pName = Extra_UtilStrsav(pNtk->pName);
src/base/abc/abcBarBuf.c:    pNtkNew->pSpec = Extra_UtilStrsav(pNtk->pSpec);
src/base/abc/abcBarBuf.c:    pNtkNew = Abc_NtkStartFrom( pNtkBase, pNtk->ntkType, pNtk->ntkFunc );
src/base/abc/abcNetlist.c://    assert( pNtk->pDesign == NULL );
src/base/abc/abcNetlist.c:    pNtkNew = Abc_NtkStartFrom( pNtk, ABC_NTK_LOGIC, pNtk->ntkFunc );
src/base/abc/abcNetlist.c:    if ( pNtk->pExdc )
src/base/abc/abcNetlist.c:        pNtkNew->pExdc = Abc_NtkToLogic( pNtk->pExdc );
src/base/abc/abcNetlist.c:    pNtkNew = Abc_NtkStartFrom( pNtk, ABC_NTK_NETLIST, pNtk->ntkFunc );
src/base/abc/abcNetlist.c:    if ( pNtk->pExdc )
src/base/abc/abcNetlist.c:        pNtkNew->pExdc = Abc_NtkToNetlist( pNtk->pExdc );
src/base/abc/abcNetlist.c:    if ( pNtk->pExdc )
src/base/abc/abcNetlist.c:        if ( Abc_NtkIsStrash(pNtk->pExdc) )
src/base/abc/abcNetlist.c:            pNtkNew->pExdc = Abc_NtkAigToLogicSop( pNtk->pExdc );
src/base/abc/abcNetlist.c:            pNtkNew->pExdc = Abc_NtkDup( pNtk->pExdc );
src/base/abc/abcNetlist.c:    if ( pNtk->pExdc )
src/base/abc/abcNetlist.c:    if ( pNtk->pExdc )
src/base/abc/abcCheck.c:        if ( pNtk->pManFunc != Abc_FrameReadLibGen() )
src/base/abc/abcCheck.c:        if ( !Abc_AigCheck( (Abc_Aig_t *)pNtk->pManFunc ) )
src/base/abc/abcCheck.c:    if ( pNtk->pExdc )
src/base/abc/abcCheck.c:        Abc_NtkCheck( pNtk->pExdc );
src/base/abc/abcCheck.c:    if ( Abc_NtkIsNetlist(pNtk) && pNtk->tName2Model )
src/base/abc/abcCheck.c:        stmm_foreach_item( pNtk->tName2Model, gen, &pName, (char **)&pNtkTemp )
src/base/abc/abcCheck.c:        if ( Nm_ManFindNameById(pObj->pNtk->pManName, pObj->Id) == NULL )
src/base/abc/abcCheck.c:        if ( Nm_ManFindNameById(pObj->pNtk->pManName, pObj->Id) == NULL )
src/base/abc/abcCheck.c:    vNameIds = Nm_ManReturnNameIds( pNtk->pManName );
src/base/abc/abcCheck.c:        if ( Vec_PtrEntry( pNtk->vObjs, NameId ) == NULL )
src/base/abc/abcCheck.c:            pName = Nm_ManFindNameById(pObj->pNtk->pManName, NameId);
src/base/abc/abcCheck.c:        int nSuppSize = Cudd_SupportSize((DdManager *)pNtk->pManFunc, (DdNode *)pNode->pData);
src/base/abc/abcCheck.c:    if ( pNtk->fHieVisited )
src/base/abc/abcCheck.c:    pNtk->fHieVisited = 1;
src/base/abc/abcCheck.c:        pNtk->fHiePath = 1;
src/base/abc/abcCheck.c:        pNtk->fHiePath = 0;
src/base/abc/abcCheck.c:    assert( Abc_NtkIsNetlist(pNtk) && pNtk->pDesign );
src/base/abc/abcCheck.c:    Vec_PtrForEachEntry( Abc_Ntk_t *, pNtk->pDesign->vModules, pTemp, i )
src/base/abc/abcCheck.c:    pNtk->fHiePath = 1;
src/base/abc/abcCheck.c:    pNtk->fHiePath = 0;
src/base/abc/abcCheck.c:    Vec_PtrForEachEntry( Abc_Ntk_t *, pNtk->pDesign->vModules, pTemp, i )
src/base/abc/abcCheck.c:        nCiId = Nm_ManFindIdByNameTwoTypes( pNtk->pManName, Abc_ObjName(pObj), ABC_OBJ_PI, ABC_OBJ_BO );
src/base/abc/abcAig.c:    if ( pNtk->nBarBufs )
src/base/abc/abcAig.c://    if ( pAnd->pNtk->pManCut )
src/base/abc/abcAig.c://        Abc_NodeGetCuts( pAnd->pNtk->pManCut, pAnd );
src/base/abc/abcAig.c://    if ( pAnd->pNtk->pManCut )
src/base/abc/abcAig.c://        Abc_NodeGetCuts( pAnd->pNtk->pManCut, pAnd );
src/base/abc/abcAig.c:    assert( Abc_ObjRegular(p0)->pNtk->pManFunc == pMan );
src/base/abc/abcAig.c:    assert( Abc_ObjRegular(p1)->pNtk->pManFunc == pMan );
src/base/abc/abcAig.c:    if ( pThis->pNtk->pManCut )
src/base/abc/abcAig.c:        Abc_NodeFreeCuts( pThis->pNtk->pManCut, pThis );
src/base/abc/abcAig.c:    return ((Abc_Aig_t *)pNtk->pManFunc)->pConst1;
src/base/abc/abcMinBase.c:    pNode->pData = Extra_bddRemapUp( (DdManager *)pNode->pNtk->pManFunc, bTemp = (DdNode *)pNode->pData );   Cudd_Ref( (DdNode *)pNode->pData );
src/base/abc/abcMinBase.c:    Cudd_RecursiveDeref( (DdManager *)pNode->pNtk->pManFunc, bTemp );
src/base/abc/abcMinBase.c:    DdManager * dd = (DdManager *)pNode->pNtk->pManFunc;
src/base/abc/abcMinBase.c:                DdManager * dd = (DdManager *)pNode->pNtk->pManFunc;
src/base/abc/abcMinBase.c:    DdManager * dd = (DdManager *)pFanin->pNtk->pManFunc;
src/base/abc/abcMinBase.c:    Hop_Man_t * pMan = (Hop_Man_t *)pFanin->pNtk->pManFunc;
src/base/abc/abcMinBase.c:    Hop_Man_t * pMan = (Hop_Man_t *)pFanin->pNtk->pManFunc;
src/base/abc/abcMinBase.c:    pMan = (Hop_Man_t *)pNode->pNtk->pManFunc;
src/base/abc/abcLib.c:            pNtk->pDesign = NULL;
src/base/abc/abcLib.c:            if ( (pNtkSave && pNtk->pManFunc == pNtkSave->pManFunc) || (pNtk->pManFunc == p->pManFunc) )
src/base/abc/abcLib.c:                pNtk->pManFunc = NULL;
src/base/abc/abcLib.c:        printf( "%2d : %20s   ", i+1, pNtk->pName );
src/base/abc/abcLib.c:    if ( st__is_member( p->tModules, (char *)pNtk->pName ) )
src/base/abc/abcLib.c:    st__insert( p->tModules, (char *)pNtk->pName, (char *)pNtk );
src/base/abc/abcLib.c:    assert( pNtk->Id == 0 );
src/base/abc/abcLib.c:    pNtk->Id = Vec_PtrSize(p->vModules);
src/base/abc/abcLib.c:    pNtk->pDesign = p;
src/base/abc/abcLib.c:    pNtk->pManFunc = p->pManFunc;           p->pManFunc = NULL;
src/base/abc/abcLib.c:        pNtk->fHieVisited = 0;
src/base/abc/abcLib.c:        if ( pNtk->fHieVisited == 0 )
src/base/abc/abcLib.c:            pNtk->fHieVisited = 0;
src/base/abc/abcNtk.c:    pNtk->ntkType     = Type;
src/base/abc/abcNtk.c:    pNtk->ntkFunc     = Func;
src/base/abc/abcNtk.c:    pNtk->vObjs       = Vec_PtrAlloc( 100 );
src/base/abc/abcNtk.c:    pNtk->vPios       = Vec_PtrAlloc( 100 );
src/base/abc/abcNtk.c:    pNtk->vPis        = Vec_PtrAlloc( 100 );
src/base/abc/abcNtk.c:    pNtk->vPos        = Vec_PtrAlloc( 100 );
src/base/abc/abcNtk.c:    pNtk->vCis        = Vec_PtrAlloc( 100 );
src/base/abc/abcNtk.c:    pNtk->vCos        = Vec_PtrAlloc( 100 );
src/base/abc/abcNtk.c:    pNtk->vBoxes      = Vec_PtrAlloc( 100 );
src/base/abc/abcNtk.c:    pNtk->vLtlProperties = Vec_PtrAlloc( 100 );
src/base/abc/abcNtk.c:    pNtk->pMmObj      = fUseMemMan? Mem_FixedStart( sizeof(Abc_Obj_t) ) : NULL;
src/base/abc/abcNtk.c:    pNtk->pMmStep     = fUseMemMan? Mem_StepStart( ABC_NUM_STEPS ) : NULL;
src/base/abc/abcNtk.c:    pNtk->nTravIds    = 1;
src/base/abc/abcNtk.c:        Vec_PtrPush( pNtk->vObjs, NULL );
src/base/abc/abcNtk.c:        pNtk->pManFunc = Abc_AigAlloc( pNtk );
src/base/abc/abcNtk.c:        pNtk->pManFunc = Mem_FlexStart();
src/base/abc/abcNtk.c:        pNtk->pManFunc = Cudd_Init( 20, 0, CUDD_UNIQUE_SLOTS, CUDD_CACHE_SLOTS, 0 );
src/base/abc/abcNtk.c:        pNtk->pManFunc = Hop_ManStart();
src/base/abc/abcNtk.c:        pNtk->pManFunc = Abc_FrameReadLibGen();
src/base/abc/abcNtk.c:    pNtk->pManName = Nm_ManCreate( 200 );
src/base/abc/abcNtk.c:    pNtk->vAttrs = Vec_PtrStart( VEC_ATTR_TOTAL_NUM );
src/base/abc/abcNtk.c:    pNtk->AndGateDelay = 0.0;
src/base/abc/abcNtk.c:    pNtkNew->nConstrs   = pNtk->nConstrs;
src/base/abc/abcNtk.c:    pNtkNew->nBarBufs   = pNtk->nBarBufs;
src/base/abc/abcNtk.c:    pNtkNew->pName = Extra_UtilStrsav(pNtk->pName);
src/base/abc/abcNtk.c:    pNtkNew->pSpec = Extra_UtilStrsav(pNtk->pSpec);
src/base/abc/abcNtk.c:    if ( pNtk->vOnehots )
src/base/abc/abcNtk.c:        pNtkNew->vOnehots = (Vec_Ptr_t *)Vec_VecDupInt( (Vec_Vec_t *)pNtk->vOnehots );
src/base/abc/abcNtk.c:    if ( pNtk->pSeqModel )
src/base/abc/abcNtk.c:        pNtkNew->pSeqModel = Abc_CexDup( pNtk->pSeqModel, Abc_NtkLatchNum(pNtk) );
src/base/abc/abcNtk.c:    if ( pNtk->vObjPerm )
src/base/abc/abcNtk.c:        pNtkNew->vObjPerm = Vec_IntDup( pNtk->vObjPerm );
src/base/abc/abcNtk.c:    pNtkNew->AndGateDelay = pNtk->AndGateDelay;
src/base/abc/abcNtk.c:    if ( pNtk->AndGateDelay != 0.0 && pNtk->pManTime != NULL && pNtk->ntkType != ABC_NTK_STRASH && Type == ABC_NTK_STRASH )
src/base/abc/abcNtk.c:            pObj->pCopy->Level = (int)(Abc_MaxFloat(0, Abc_NodeReadArrivalWorst(pObj)) / pNtk->AndGateDelay);
src/base/abc/abcNtk.c:    pNtkNew->nConstrs   = pNtk->nConstrs;
src/base/abc/abcNtk.c:    pNtkNew->nBarBufs   = pNtk->nBarBufs;
src/base/abc/abcNtk.c:    pNtkNew->pName = Extra_UtilStrsav(pNtk->pName);
src/base/abc/abcNtk.c:    pNtkNew->pSpec = Extra_UtilStrsav(pNtk->pSpec);
src/base/abc/abcNtk.c:    if ( pNtk->vOnehots )
src/base/abc/abcNtk.c:        pNtkNew->vOnehots = (Vec_Ptr_t *)Vec_VecDupInt( (Vec_Vec_t *)pNtk->vOnehots );
src/base/abc/abcNtk.c:    if ( pNtk->pSeqModel )
src/base/abc/abcNtk.c:        pNtkNew->pSeqModel = Abc_CexDup( pNtk->pSeqModel, Abc_NtkLatchNum(pNtk) );
src/base/abc/abcNtk.c:    if ( pNtk->vObjPerm )
src/base/abc/abcNtk.c:        pNtkNew->vObjPerm = Vec_IntDup( pNtk->vObjPerm );
src/base/abc/abcNtk.c:    pNtkNew->AndGateDelay = pNtk->AndGateDelay;
src/base/abc/abcNtk.c:    if ( pNtk->AndGateDelay != 0.0 && pNtk->pManTime != NULL && pNtk->ntkType != ABC_NTK_STRASH && Type == ABC_NTK_STRASH )
src/base/abc/abcNtk.c:            pObj->pCopy->Level = (int)(Abc_MaxFloat(0, Abc_NodeReadArrivalWorst(pObj)) / pNtk->AndGateDelay);
src/base/abc/abcNtk.c:    pNtkNew->nConstrs   = pNtk->nConstrs;
src/base/abc/abcNtk.c:    pNtkNew->nBarBufs   = pNtk->nBarBufs;
src/base/abc/abcNtk.c:    pNtkNew->pName = Extra_UtilStrsav(pNtk->pName);
src/base/abc/abcNtk.c:    pNtkNew->pSpec = Extra_UtilStrsav(pNtk->pSpec);
src/base/abc/abcNtk.c:    if ( pNtk->vObjPerm )
src/base/abc/abcNtk.c:        pNtkNew->vObjPerm = Vec_IntDup( pNtk->vObjPerm );
src/base/abc/abcNtk.c:    pNtkNew->AndGateDelay = pNtk->AndGateDelay;
src/base/abc/abcNtk.c:    if ( pNtk->pManTime )
src/base/abc/abcNtk.c:    if ( pNtk->vPhases )
src/base/abc/abcNtk.c:    if ( pNtk->pWLoadUsed )
src/base/abc/abcNtk.c:        pNtkNew->pWLoadUsed = Abc_UtilStrsav( pNtk->pWLoadUsed );
src/base/abc/abcNtk.c:    pNtkNew = Abc_NtkStartFrom( pNtk, pNtk->ntkType, pNtk->ntkFunc );
src/base/abc/abcNtk.c:    if ( pNtk->pExdc )
src/base/abc/abcNtk.c:        pNtkNew->pExdc = Abc_NtkDup( pNtk->pExdc );
src/base/abc/abcNtk.c:    if ( pNtk->pExcare )
src/base/abc/abcNtk.c:        pNtkNew->pExcare = Abc_NtkDup( (Abc_Ntk_t *)pNtk->pExcare );
src/base/abc/abcNtk.c:    if ( pNtk->pManTime )
src/base/abc/abcNtk.c:    if ( pNtk->vPhases )
src/base/abc/abcNtk.c:    if ( pNtk->pWLoadUsed )
src/base/abc/abcNtk.c:        pNtkNew->pWLoadUsed = Abc_UtilStrsav( pNtk->pWLoadUsed );
src/base/abc/abcNtk.c:    pNtk->pCopy = pNtkNew;
src/base/abc/abcNtk.c:    pNtkNew = Abc_NtkStartFrom( pNtk, pNtk->ntkType, pNtk->ntkFunc );
src/base/abc/abcNtk.c:    if ( pNtk->pExdc )
src/base/abc/abcNtk.c:        pNtkNew->pExdc = Abc_NtkDup( pNtk->pExdc );
src/base/abc/abcNtk.c:    if ( pNtk->pExcare )
src/base/abc/abcNtk.c:        pNtkNew->pExcare = Abc_NtkDup( (Abc_Ntk_t *)pNtk->pExcare );
src/base/abc/abcNtk.c:    if ( pNtk->pManTime )
src/base/abc/abcNtk.c:    if ( pNtk->vPhases )
src/base/abc/abcNtk.c:    if ( pNtk->pWLoadUsed )
src/base/abc/abcNtk.c:        pNtkNew->pWLoadUsed = Abc_UtilStrsav( pNtk->pWLoadUsed );
src/base/abc/abcNtk.c:    pNtk->pCopy = pNtkNew;
src/base/abc/abcNtk.c:    assert( pNtk->nBarBufs2 > 0 );
src/base/abc/abcNtk.c:    pNtkNew = Abc_NtkStartFrom( pNtk, pNtk->ntkType, pNtk->ntkFunc );
src/base/abc/abcNtk.c:    if ( pNtk->pExdc )
src/base/abc/abcNtk.c:        pNtkNew->pExdc = Abc_NtkDup( pNtk->pExdc );
src/base/abc/abcNtk.c:    if ( pNtk->pExcare )
src/base/abc/abcNtk.c:        pNtkNew->pExcare = Abc_NtkDup( (Abc_Ntk_t *)pNtk->pExcare );
src/base/abc/abcNtk.c:    if ( pNtk->pManTime )
src/base/abc/abcNtk.c:    if ( pNtk->vPhases )
src/base/abc/abcNtk.c:    if ( pNtk->pWLoadUsed )
src/base/abc/abcNtk.c:        pNtkNew->pWLoadUsed = Abc_UtilStrsav( pNtk->pWLoadUsed );
src/base/abc/abcNtk.c:    pNtk->pCopy = pNtkNew;
src/base/abc/abcNtk.c:    pNtkNew = Abc_NtkAlloc( pNtk->ntkType, pNtk->ntkFunc, 1 );
src/base/abc/abcNtk.c:    pNtkNew->nConstrs   = pNtk->nConstrs;
src/base/abc/abcNtk.c:    pNtkNew->nBarBufs   = pNtk->nBarBufs;
src/base/abc/abcNtk.c:    pNtkNew->pName = Extra_UtilStrsav(pNtk->pName);
src/base/abc/abcNtk.c:    pNtkNew->pSpec = Extra_UtilStrsav(pNtk->pSpec);
src/base/abc/abcNtk.c:    pNtkNew = Abc_NtkAlloc( pNtk->ntkType, pNtk->ntkFunc, 1 );
src/base/abc/abcNtk.c:    sprintf( Buffer, "%s%s", pNtk->pName, "_2x" );
src/base/abc/abcNtk.c:    pNtkNew = Abc_NtkAlloc( pNtk->ntkType, pNtk->ntkFunc, 1 );
src/base/abc/abcNtk.c:    sprintf( Buffer, "%s%s", pNtk->pName, "_bot" );
src/base/abc/abcNtk.c:    pNtkNew = Abc_NtkAlloc( pNtk->ntkType, pNtk->ntkFunc, 1 );
src/base/abc/abcNtk.c:    sprintf( Buffer, "%s_%s", pNtk->pName, pNodeName );
src/base/abc/abcNtk.c:    pNtkNew = Abc_NtkAlloc( pNtk->ntkType, pNtk->ntkFunc, 1 );
src/base/abc/abcNtk.c:    sprintf( Buffer, "%s_part", pNtk->pName );
src/base/abc/abcNtk.c:    pNtkNew = Abc_NtkAlloc( pNtk->ntkType, pNtk->ntkFunc, 1 );
src/base/abc/abcNtk.c:    sprintf( Buffer, "%s_%s", pNtk->pName, pNodeName );
src/base/abc/abcNtk.c:    pNtkNew->pName = Extra_UtilStrsav(pNtk->pName);
src/base/abc/abcNtk.c:    pNtkNew = Abc_NtkAlloc( pNtk->ntkType, pNtk->ntkFunc, 1 );
src/base/abc/abcNtk.c:    if ( pNtk->pExdc )
src/base/abc/abcNtk.c:        Abc_NtkDelete( pNtk->pExdc );
src/base/abc/abcNtk.c:    if ( pNtk->pExcare )
src/base/abc/abcNtk.c:        Abc_NtkDelete( (Abc_Ntk_t *)pNtk->pExcare );
src/base/abc/abcNtk.c:            Cudd_RecursiveDeref( (DdManager *)pNtk->pManFunc, (DdNode *)pObj->pData );
src/base/abc/abcNtk.c://        if ( pNtk->pMmObj && pObj->vFanouts.nCap * 4 > LargePiece )
src/base/abc/abcNtk.c:    if ( pNtk->pMmStep == NULL )
src/base/abc/abcNtk.c:    if ( pNtk->pMmObj == NULL )
src/base/abc/abcNtk.c:    Vec_PtrFree( pNtk->vPios );
src/base/abc/abcNtk.c:    Vec_PtrFree( pNtk->vPis );
src/base/abc/abcNtk.c:    Vec_PtrFree( pNtk->vPos );
src/base/abc/abcNtk.c:    Vec_PtrFree( pNtk->vCis );
src/base/abc/abcNtk.c:    Vec_PtrFree( pNtk->vCos );
src/base/abc/abcNtk.c:    Vec_PtrFree( pNtk->vObjs );
src/base/abc/abcNtk.c:    Vec_PtrFree( pNtk->vBoxes );
src/base/abc/abcNtk.c:    ABC_FREE( pNtk->vTravIds.pArray );
src/base/abc/abcNtk.c:    if ( pNtk->vLevelsR ) Vec_IntFree( pNtk->vLevelsR );
src/base/abc/abcNtk.c:    ABC_FREE( pNtk->pModel );
src/base/abc/abcNtk.c:    ABC_FREE( pNtk->pSeqModel );
src/base/abc/abcNtk.c:    if ( pNtk->vSeqModelVec )
src/base/abc/abcNtk.c:        Vec_PtrFreeFree( pNtk->vSeqModelVec );
src/base/abc/abcNtk.c:    TotalMemory += pNtk->pMmObj? Mem_FixedReadMemUsage(pNtk->pMmObj)  : 0;
src/base/abc/abcNtk.c:    TotalMemory += pNtk->pMmStep? Mem_StepReadMemUsage(pNtk->pMmStep) : 0;
src/base/abc/abcNtk.c:    if ( pNtk->pMmObj )
src/base/abc/abcNtk.c:        Mem_FixedStop( pNtk->pMmObj, 0 );
src/base/abc/abcNtk.c:    if ( pNtk->pMmStep )
src/base/abc/abcNtk.c:        Mem_StepStop ( pNtk->pMmStep, 0 );
src/base/abc/abcNtk.c:    Nm_ManFree( pNtk->pManName );
src/base/abc/abcNtk.c:    if ( pNtk->pManTime )
src/base/abc/abcNtk.c:        Abc_ManTimeStop( pNtk->pManTime );
src/base/abc/abcNtk.c:    Vec_IntFreeP( &pNtk->vPhases );
src/base/abc/abcNtk.c:        Abc_AigFree( (Abc_Aig_t *)pNtk->pManFunc );
src/base/abc/abcNtk.c:        Mem_FlexStop( (Mem_Flex_t *)pNtk->pManFunc, 0 );
src/base/abc/abcNtk.c:        Extra_StopManager( (DdManager *)pNtk->pManFunc );
src/base/abc/abcNtk.c:        { if ( pNtk->pManFunc ) Hop_ManStop( (Hop_Man_t *)pNtk->pManFunc ); }
src/base/abc/abcNtk.c:        pNtk->pManFunc = NULL;
src/base/abc/abcNtk.c:    if ( pNtk->pDesign )
src/base/abc/abcNtk.c:        Abc_DesFree( pNtk->pDesign, pNtk );
src/base/abc/abcNtk.c:        pNtk->pDesign = NULL;
src/base/abc/abcNtk.c://    if ( pNtk->pBlackBoxes ) 
src/base/abc/abcNtk.c://        Vec_IntFree( pNtk->pBlackBoxes );
src/base/abc/abcNtk.c:    Vec_PtrForEachEntry( Abc_Obj_t *, pNtk->vAttrs, pAttrMan, i )
src/base/abc/abcNtk.c:    assert( pNtk->pSCLib == NULL );
src/base/abc/abcNtk.c:    Vec_IntFreeP( &pNtk->vGates );
src/base/abc/abcNtk.c:    Vec_PtrFree( pNtk->vAttrs );
src/base/abc/abcNtk.c:    Vec_IntFreeP( &pNtk->vNameIds );
src/base/abc/abcNtk.c:    ABC_FREE( pNtk->pWLoadUsed );
src/base/abc/abcNtk.c:    ABC_FREE( pNtk->pName );
src/base/abc/abcNtk.c:    ABC_FREE( pNtk->pSpec );
src/base/abc/abcNtk.c:    ABC_FREE( pNtk->pLutTimes );
src/base/abc/abcNtk.c:    if ( pNtk->vOnehots )
src/base/abc/abcNtk.c:        Vec_VecFree( (Vec_Vec_t *)pNtk->vOnehots );
src/base/abc/abcNtk.c:    Vec_PtrFreeP( &pNtk->vLtlProperties );
src/base/abc/abcNtk.c:    Vec_IntFreeP( &pNtk->vObjPerm );
src/base/abc/abcNtk.c:    Vec_IntFreeP( &pNtk->vTopo );
src/base/abc/abcNtk.c:    Vec_IntFreeP( &pNtk->vFins );
src/base/abc/abcNtk.c:        printf( "Warning: Constant-0 drivers added to %d non-driven nets in network \"%s\":\n", Vec_PtrSize(vNets), pNtk->pName );
src/base/abc/abcNtk.c:    Vec_PtrForEachEntryReverse( Abc_Obj_t *, pNtk->vBoxes, pObj, i )
src/base/abc/abcNtk.c:    Vec_PtrClear( pNtk->vPis );
src/base/abc/abcNtk.c:            pNtk->nObjCounts[ABC_OBJ_PI]++;
src/base/abc/abcNtk.c:            pNtk->nObjCounts[ABC_OBJ_BO]--;
src/base/abc/abcNtk.c:        Vec_PtrPush( pNtk->vPis, pObj );
src/base/abc/abcNtk.c:        Vec_PtrClear( pNtk->vPos );
src/base/abc/abcNtk.c:                Vec_PtrPush( pNtk->vPos, pObj );
src/base/abc/abcNtk.c:        Vec_PtrFree( pNtk->vCos );
src/base/abc/abcNtk.c:        pNtk->vCos = NULL;
src/base/abc/abcNtk.c:        pNtk->vCos = Vec_PtrDup( pNtk->vPos );
src/base/abc/abcNtk.c:            Abc_AigCleanup( (Abc_Aig_t *)pNtk->pManFunc );
src/base/abc/abcNtk.c:        Vec_PtrClear( pNtk->vPos );
src/base/abc/abcNtk.c:                pNtk->nObjCounts[ABC_OBJ_PO]++;
src/base/abc/abcNtk.c:                pNtk->nObjCounts[ABC_OBJ_BI]--;
src/base/abc/abcNtk.c:            Vec_PtrPush( pNtk->vPos, pObj );
src/base/abc/abcNtk.c:    Vec_PtrClear( pNtk->vPis );
src/base/abc/abcNtk.c:            Vec_PtrPush( pNtk->vPis, pObj );
src/base/abc/abcNtk.c:        pNtk->nObjCounts[ABC_OBJ_PI]--;
src/base/abc/abcNtk.c:        pNtk->nObjCounts[ABC_OBJ_BO]++;
src/base/abc/abcNtk.c:    Vec_PtrClear( pNtk->vPos );
src/base/abc/abcNtk.c:            Vec_PtrPush( pNtk->vPos, pObj );
src/base/abc/abcNtk.c:        pNtk->nObjCounts[ABC_OBJ_PO]--;
src/base/abc/abcNtk.c:        pNtk->nObjCounts[ABC_OBJ_BI]++;
src/base/abc/abcNtk.c:    Vec_PtrFree( pNtk->vPos );  pNtk->vPos = vPosLeft;
src/base/abc/abcNtk.c:    Vec_PtrFree( pNtk->vCos );  pNtk->vCos = vCosLeft;
src/base/abc/abcNtk.c:        Abc_AigCleanup( (Abc_Aig_t *)pNtk->pManFunc );
src/base/abc/abcNtk.c:                pNtk->vObjs->pArray[pObj->Id] = NULL;
src/base/abc/abcNtk.c:                pNtk->nObjCounts[pObj->Type]--;
src/base/abc/abcNtk.c:                pNtk->nObjs--;
src/base/abc/abcNtk.c:                    pNtk->vObjs->pArray[pObj->Id] = NULL;
src/base/abc/abcNtk.c:                    pNtk->nObjCounts[pObj->Type]--;
src/base/abc/abcNtk.c:                    pNtk->nObjs--;
src/base/abc/abcNtk.c:            Vec_PtrWriteEntry( pNtk->vPos, m++, pObj );
src/base/abc/abcNtk.c:        Vec_PtrWriteEntry( pNtk->vCos, k++, pObj );
src/base/abc/abcNtk.c:    Vec_PtrShrink( pNtk->vPos, m );
src/base/abc/abcNtk.c:    Vec_PtrShrink( pNtk->vCos, k );
src/base/abc/abcNtk.c:                pNtk->vObjs->pArray[pObj->Id] = NULL;
src/base/abc/abcNtk.c:                pNtk->nObjCounts[pObj->Type]--;
src/base/abc/abcNtk.c:                pNtk->nObjs--;
src/base/abc/abcNtk.c:            Vec_PtrWriteEntry( pNtk->vPis, m++, pObj );
src/base/abc/abcNtk.c:        Vec_PtrWriteEntry( pNtk->vCis, k++, pObj );
src/base/abc/abcNtk.c:    Vec_PtrShrink( pNtk->vPis, m );
src/base/abc/abcNtk.c:    Vec_PtrShrink( pNtk->vCis, k );
src/base/abc/abcNtk.c://            Nm_ManDeleteIdName( pNtk->pManName, Abc_ObjId(pObj) );
src/base/abc/abcNtk.c:    Counter = Abc_AigCleanup( (Abc_Aig_t *)pNtk->pManFunc );
src/base/abc/abcNtk.c:    Abc_AigCleanup( (Abc_Aig_t *)pNtk->pManFunc );
src/base/abc/abcNtk.c:        pTemp = (Abc_Obj_t *)Vec_PtrEntry( pNtk->vPis, i );
src/base/abc/abcNtk.c:        Vec_PtrWriteEntry( pNtk->vPis, i, Vec_PtrEntry(pNtk->vPis, k) );
src/base/abc/abcNtk.c:        Vec_PtrWriteEntry( pNtk->vPis, k, pTemp );
src/base/abc/abcNtk.c:        pTemp = (Abc_Obj_t *)Vec_PtrEntry( pNtk->vCis, i );
src/base/abc/abcNtk.c:        Vec_PtrWriteEntry( pNtk->vCis, i, Vec_PtrEntry(pNtk->vCis, k) );
src/base/abc/abcNtk.c:        Vec_PtrWriteEntry( pNtk->vCis, k, pTemp );
src/base/abc/abcNtk.c:        pTemp = (Abc_Obj_t *)Vec_PtrEntry( pNtk->vPos, i );
src/base/abc/abcNtk.c:        Vec_PtrWriteEntry( pNtk->vPos, i, Vec_PtrEntry(pNtk->vPos, k) );
src/base/abc/abcNtk.c:        Vec_PtrWriteEntry( pNtk->vPos, k, pTemp );
src/base/abc/abcNtk.c:        pTemp = (Abc_Obj_t *)Vec_PtrEntry( pNtk->vCos, i );
src/base/abc/abcNtk.c:        Vec_PtrWriteEntry( pNtk->vCos, i, Vec_PtrEntry(pNtk->vCos, k) );
src/base/abc/abcNtk.c:        Vec_PtrWriteEntry( pNtk->vCos, k, pTemp );
src/base/abc/abcNtk.c:        pTemp = (Abc_Obj_t *)Vec_PtrEntry( pNtk->vBoxes, i );
src/base/abc/abcNtk.c:        Vec_PtrWriteEntry( pNtk->vBoxes, i, Vec_PtrEntry(pNtk->vBoxes, k) );
src/base/abc/abcNtk.c:        Vec_PtrWriteEntry( pNtk->vBoxes, k, pTemp );
src/base/abc/abcNtk.c:        pTemp = (Abc_Obj_t *)Vec_PtrEntry( pNtk->vCis, Abc_NtkPiNum(pNtk)+i );
src/base/abc/abcNtk.c:        Vec_PtrWriteEntry( pNtk->vCis, Abc_NtkPiNum(pNtk)+i, Vec_PtrEntry(pNtk->vCis, Abc_NtkPiNum(pNtk)+k) );
src/base/abc/abcNtk.c:        Vec_PtrWriteEntry( pNtk->vCis, Abc_NtkPiNum(pNtk)+k, pTemp );
src/base/abc/abcNtk.c:        pTemp = (Abc_Obj_t *)Vec_PtrEntry( pNtk->vCos, Abc_NtkPoNum(pNtk)+i );
src/base/abc/abcNtk.c:        Vec_PtrWriteEntry( pNtk->vCos, Abc_NtkPoNum(pNtk)+i, Vec_PtrEntry(pNtk->vCos, Abc_NtkPoNum(pNtk)+k) );
src/base/abc/abcNtk.c:        Vec_PtrWriteEntry( pNtk->vCos, Abc_NtkPoNum(pNtk)+k, pTemp );
src/base/abc/abcNtk.c:    Vec_IntFreeP( &pNtk->vObjPerm );
src/base/abc/abcNtk.c:    pNtk->vObjPerm = Vec_IntAlloc( Abc_NtkPiNum(pNtk) + Abc_NtkPoNum(pNtk) + Abc_NtkLatchNum(pNtk) );
src/base/abc/abcNtk.c:        Vec_IntPush( pNtk->vObjPerm, Entry );
src/base/abc/abcNtk.c:        Vec_IntPush( pNtk->vObjPerm, Entry );
src/base/abc/abcNtk.c:        Vec_IntPush( pNtk->vObjPerm, Entry );
src/base/abc/abcNtk.c:    qsort( (void *)Vec_PtrArray(pNtk->vPis), (size_t)Vec_PtrSize(pNtk->vPis), sizeof(Abc_Obj_t *), 
src/base/abc/abcNtk.c:    Vec_PtrClear( pNtk->vCis );
src/base/abc/abcNtk.c:    Vec_PtrForEachEntry( Abc_Obj_t *, pNtk->vPis, pNode, i )
src/base/abc/abcNtk.c:        Vec_PtrPush( pNtk->vCis, pNode );
src/base/abc/abcNtk.c:    if ( pNtk->vObjPerm == NULL )
src/base/abc/abcNtk.c:    pInputs  = Vec_IntArray( pNtk->vObjPerm );
src/base/abc/abcNtk.c:    Vec_PtrFreeP( &pNtk->vPis );
src/base/abc/abcNtk.c:    pNtk->vPis = vTemp;
src/base/abc/abcNtk.c:    Vec_PtrFreeP( &pNtk->vPos );
src/base/abc/abcNtk.c:    pNtk->vPos = vTemp;
src/base/abc/abcNtk.c:    vTemp  = Vec_PtrDup( pNtk->vPis );
src/base/abc/abcNtk.c:    vTemp2 = Vec_PtrDup( pNtk->vPos );
src/base/abc/abcNtk.c:    Vec_PtrFreeP( &pNtk->vCis );
src/base/abc/abcNtk.c:    Vec_PtrFreeP( &pNtk->vCos );
src/base/abc/abcNtk.c:    Vec_PtrFreeP( &pNtk->vBoxes );
src/base/abc/abcNtk.c:    pNtk->vCis   = vTemp;
src/base/abc/abcNtk.c:    pNtk->vCos   = vTemp2;
src/base/abc/abcNtk.c:    pNtk->vBoxes = vLatch;
src/base/abc/abcNtk.c:    Vec_IntFreeP( &pNtk->vObjPerm );
src/base/abc/abcNtk.c:    pNtk->pName = Extra_UtilStrsav( pName );
src/base/abc/abcNtk.c:        pObj->pData = Abc_SopRegister( (Mem_Flex_t*)pNtk->pManFunc, pSop );
src/base/abc/abcNtk.c:    pNtk->pName = Extra_UtilStrsav( pName );
src/base/abc/abcNtk.c:            pAbcObj  = Abc_AigAnd( (Abc_Aig_t *)pNtk->pManFunc, pAbcObj0, pAbcObj1 );
src/base/abc/abcNtk.c:            pAbcObj  = Abc_AigAnd( (Abc_Aig_t *)pNtk->pManFunc, pAbcObj0, pAbcObj1 );
src/base/abc/abcDfs.c:    if ( pNtk->nBarBufs2 > 0 )
src/base/abc/abcDfs.c:        pNew->pName = Abc_UtilStrsav( pNtk->pName );
src/base/abc/abcDfs.c:        pNew->pSpec = Abc_UtilStrsav( pNtk->pSpec );
src/base/abc/abcDfs.c:        if ( i < Abc_NtkCoNum(pNtk) - pNtk->nBarBufs )
src/base/abc/abcDfs.c:        if ( i >= Abc_NtkCoNum(pNtk) - pNtk->nBarBufs )
src/base/abc/abcDfs.c:    if ( pNtk->pManTime == NULL || pNtk->AndGateDelay <= 0 )
src/base/abc/abcDfs.c:            pNode->Level = (int)(Abc_MaxFloat(0, Abc_NodeReadArrivalWorst(pNode)) / pNtk->AndGateDelay);
src/base/abc/abcDfs.c:    if ( pNtk->nBarBufs == 0 )
src/base/abc/abcDfs.c:            if ( i < pNtk->nBarBufs )
src/base/abc/abcShow.c:    DdManager * dd = (DdManager *)pNode->pNtk->pManFunc;
src/base/abc/abcShow.c:    Abc_ShowGetFileName( pNtk->pName, FileNameDot );
src/base/abc/abcShow.c:    nBarBufs = pNtk->nBarBufs;
src/base/abc/abcShow.c:    pNtk->nBarBufs = 0;
src/base/abc/abcShow.c:    pNtk->nBarBufs = nBarBufs;
src/base/abc/abcShow.c:    Abc_ShowGetFileName( pNtk->pName, FileNameDot );
src/base/abc/abcObj.c:    if ( pNtk->pMmObj )
src/base/abc/abcObj.c:        pObj = (Abc_Obj_t *)Mem_FixedEntryFetch( pNtk->pMmObj );
src/base/abc/abcObj.c://    if ( pNtk->pMmStep && pObj->vFanouts.nCap * 4 > LargePiece )
src/base/abc/abcObj.c:    if ( pNtk->pMmStep == NULL )
src/base/abc/abcObj.c:    if ( pNtk->pMmObj )
src/base/abc/abcObj.c:        Mem_FixedEntryRecycle( pNtk->pMmObj, (char *)pObj );
src/base/abc/abcObj.c:    pObj->Id = pNtk->vObjs->nSize;
src/base/abc/abcObj.c:    Vec_PtrPush( pNtk->vObjs, pObj );
src/base/abc/abcObj.c:    pNtk->nObjCounts[Type]++;
src/base/abc/abcObj.c:    pNtk->nObjs++;
src/base/abc/abcObj.c://            pObj->iTemp = Vec_PtrSize(pNtk->vCis);
src/base/abc/abcObj.c:            Vec_PtrPush( pNtk->vPis, pObj );
src/base/abc/abcObj.c:            Vec_PtrPush( pNtk->vCis, pObj );
src/base/abc/abcObj.c://            pObj->iTemp = Vec_PtrSize(pNtk->vCos);
src/base/abc/abcObj.c:            Vec_PtrPush( pNtk->vPos, pObj );
src/base/abc/abcObj.c:            Vec_PtrPush( pNtk->vCos, pObj );
src/base/abc/abcObj.c:            if ( pNtk->vCos ) Vec_PtrPush( pNtk->vCos, pObj );
src/base/abc/abcObj.c:            if ( pNtk->vCis ) Vec_PtrPush( pNtk->vCis, pObj );
src/base/abc/abcObj.c:            if ( pNtk->vBoxes ) Vec_PtrPush( pNtk->vBoxes, pObj );
src/base/abc/abcObj.c:    if ( Nm_ManFindNameById(pObj->pNtk->pManName, pObj->Id) )
src/base/abc/abcObj.c:        Nm_ManDeleteIdName(pObj->pNtk->pManName, pObj->Id);
src/base/abc/abcObj.c:    Vec_PtrWriteEntry( pNtk->vObjs, pObj->Id, NULL );
src/base/abc/abcObj.c:    pNtk->nObjCounts[pObj->Type]--;
src/base/abc/abcObj.c:    pNtk->nObjs--;
src/base/abc/abcObj.c:            Vec_PtrRemove( pNtk->vPis, pObj );
src/base/abc/abcObj.c:            Vec_PtrRemove( pNtk->vCis, pObj );
src/base/abc/abcObj.c:            Vec_PtrRemove( pNtk->vPos, pObj );
src/base/abc/abcObj.c:            Vec_PtrRemove( pNtk->vCos, pObj );
src/base/abc/abcObj.c:            if ( pNtk->vCos ) Vec_PtrRemove( pNtk->vCos, pObj );
src/base/abc/abcObj.c:            if ( pNtk->vCis ) Vec_PtrRemove( pNtk->vCis, pObj );
src/base/abc/abcObj.c:                Cudd_RecursiveDeref( (DdManager *)pNtk->pManFunc, (DdNode *)pObj->pData );
src/base/abc/abcObj.c:            if ( pNtk->vBoxes ) Vec_PtrRemove( pNtk->vBoxes, pObj );
src/base/abc/abcObj.c:    if ( Nm_ManFindNameById(pObj->pNtk->pManName, pObj->Id) )
src/base/abc/abcObj.c:        Nm_ManDeleteIdName(pObj->pNtk->pManName, pObj->Id);
src/base/abc/abcObj.c:    Vec_PtrWriteEntry( pObj->pNtk->vObjs, pObj->Id, NULL );
src/base/abc/abcObj.c:    pObj->pNtk->nObjCounts[pObj->Type]--;
src/base/abc/abcObj.c:    pObj->pNtk->nObjs--;
src/base/abc/abcObj.c:        if ( pNtkNew->ntkFunc == pObj->pNtk->ntkFunc ) 
src/base/abc/abcObj.c:                pObjNew->pData = Cudd_bddTransfer((DdManager *)pObj->pNtk->pManFunc, (DdManager *)pNtkNew->pManFunc, (DdNode *)pObj->pData), Cudd_Ref((DdNode *)pObjNew->pData);
src/base/abc/abcObj.c:                pObjNew->pData = Hop_Transfer((Hop_Man_t *)pObj->pNtk->pManFunc, (Hop_Man_t *)pNtkNew->pManFunc, (Hop_Obj_t *)pObj->pData, Abc_ObjFaninNum(pObj));
src/base/abc/abcObj.c:    Num = Nm_ManFindIdByName( pNtk->pManName, pName, ABC_OBJ_PO );
src/base/abc/abcObj.c:    Num = Nm_ManFindIdByName( pNtk->pManName, pName, ABC_OBJ_BI );
src/base/abc/abcObj.c:    Num = Nm_ManFindIdByName( pNtk->pManName, pName, ABC_OBJ_NODE );
src/base/abc/abcObj.c:    ObjId = Nm_ManFindIdByName( pNtk->pManName, pName, ABC_OBJ_NET );
src/base/abc/abcObj.c:    Num = Nm_ManFindIdByName( pNtk->pManName, pName, ABC_OBJ_PI );
src/base/abc/abcObj.c:    Num = Nm_ManFindIdByName( pNtk->pManName, pName, ABC_OBJ_BO );
src/base/abc/abcObj.c:    Num = Nm_ManFindIdByName( pNtk->pManName, pName, ABC_OBJ_PO );
src/base/abc/abcObj.c:    Num = Nm_ManFindIdByName( pNtk->pManName, pName, ABC_OBJ_BI );
src/base/abc/abcObj.c:        Nm_ManStoreIdName( pNtk->pManName, pNet->Id, pNet->Type, pName, NULL );
src/base/abc/abcObj.c:        pNode->pData = Abc_SopRegister( (Mem_Flex_t *)pNtk->pManFunc, " 0\n" );
src/base/abc/abcObj.c:        pNode->pData = Cudd_ReadLogicZero((DdManager *)pNtk->pManFunc), Cudd_Ref( (DdNode *)pNode->pData );
src/base/abc/abcObj.c:        pNode->pData = Hop_ManConst0((Hop_Man_t *)pNtk->pManFunc);
src/base/abc/abcObj.c:        pNode->pData = Abc_SopRegister( (Mem_Flex_t *)pNtk->pManFunc, " 1\n" );
src/base/abc/abcObj.c:        pNode->pData = Cudd_ReadOne((DdManager *)pNtk->pManFunc), Cudd_Ref( (DdNode *)pNode->pData );
src/base/abc/abcObj.c:        pNode->pData = Hop_ManConst1((Hop_Man_t *)pNtk->pManFunc);
src/base/abc/abcObj.c:        pNode->pData = Abc_SopRegister( (Mem_Flex_t *)pNtk->pManFunc, "0 1\n" );
src/base/abc/abcObj.c:        pNode->pData = Cudd_Not(Cudd_bddIthVar((DdManager *)pNtk->pManFunc,0)), Cudd_Ref( (DdNode *)pNode->pData );
src/base/abc/abcObj.c:        pNode->pData = Hop_Not(Hop_IthVar((Hop_Man_t *)pNtk->pManFunc,0));
src/base/abc/abcObj.c:        pNode->pData = Abc_SopRegister( (Mem_Flex_t *)pNtk->pManFunc, "1 1\n" );
src/base/abc/abcObj.c:        pNode->pData = Cudd_bddIthVar((DdManager *)pNtk->pManFunc,0), Cudd_Ref( (DdNode *)pNode->pData );
src/base/abc/abcObj.c:        pNode->pData = Hop_IthVar((Hop_Man_t *)pNtk->pManFunc,0);
src/base/abc/abcObj.c:        pNode->pData = Abc_SopCreateAnd( (Mem_Flex_t *)pNtk->pManFunc, Vec_PtrSize(vFanins), NULL );
src/base/abc/abcObj.c:        pNode->pData = Extra_bddCreateAnd( (DdManager *)pNtk->pManFunc, Vec_PtrSize(vFanins) ), Cudd_Ref((DdNode *)pNode->pData); 
src/base/abc/abcObj.c:        pNode->pData = Hop_CreateAnd( (Hop_Man_t *)pNtk->pManFunc, Vec_PtrSize(vFanins) ); 
src/base/abc/abcObj.c:        pNode->pData = Abc_SopCreateOr( (Mem_Flex_t *)pNtk->pManFunc, Vec_PtrSize(vFanins), NULL );
src/base/abc/abcObj.c:        pNode->pData = Extra_bddCreateOr( (DdManager *)pNtk->pManFunc, Vec_PtrSize(vFanins) ), Cudd_Ref((DdNode *)pNode->pData); 
src/base/abc/abcObj.c:        pNode->pData = Hop_CreateOr( (Hop_Man_t *)pNtk->pManFunc, Vec_PtrSize(vFanins) ); 
src/base/abc/abcObj.c:        pNode->pData = Abc_SopCreateXorSpecial( (Mem_Flex_t *)pNtk->pManFunc, Vec_PtrSize(vFanins) );
src/base/abc/abcObj.c:        pNode->pData = Extra_bddCreateExor( (DdManager *)pNtk->pManFunc, Vec_PtrSize(vFanins) ), Cudd_Ref((DdNode *)pNode->pData); 
src/base/abc/abcObj.c:        pNode->pData = Hop_CreateExor( (Hop_Man_t *)pNtk->pManFunc, Vec_PtrSize(vFanins) ); 
src/base/abc/abcObj.c:        pNode->pData = Abc_SopRegister( (Mem_Flex_t *)pNtk->pManFunc, "11- 1\n0-1 1\n" );
src/base/abc/abcObj.c:        pNode->pData = Cudd_bddIte((DdManager *)pNtk->pManFunc,Cudd_bddIthVar((DdManager *)pNtk->pManFunc,0),Cudd_bddIthVar((DdManager *)pNtk->pManFunc,1),Cudd_bddIthVar((DdManager *)pNtk->pManFunc,2)), Cudd_Ref( (DdNode *)pNode->pData );
src/base/abc/abcObj.c:        pNode->pData = Hop_Mux((Hop_Man_t *)pNtk->pManFunc,Hop_IthVar((Hop_Man_t *)pNtk->pManFunc,0),Hop_IthVar((Hop_Man_t *)pNtk->pManFunc,1),Hop_IthVar((Hop_Man_t *)pNtk->pManFunc,2));
src/base/abc/abcObj.c:        pNode->pData = Hop_Complement( (Hop_Man_t *)pNode->pNtk->pManFunc, (Hop_Obj_t *)pNode->pData, iFanin );
src/base/abc/abcObj.c:        DdManager * dd = (DdManager *)pNode->pNtk->pManFunc;
src/base/abc/abcHieNew.c:        Mem += 16 * pNtk->nObjsAlloc;
src/base/abc/abcHieNew.c:        Mem += 16 * pNtk->nObjsUsed;
src/base/abc/abcHieNew.c:    if ( pNtk->fMark )
src/base/abc/abcHieNew.c:    pNtk->fMark = 1;
src/base/abc/abcHieNew.c:    Vec_IntPush( vOrder, pNtk->Id );
src/base/abc/abcHieNew.c:        pNtk->fMark = 0;
src/base/abc/abcHieNew.c:        if ( pNtk->fMark == 0 )
src/base/abc/abcHieNew.c:            Vec_IntPush( vOrder, pNtk->Id );
src/base/abc/abcHieNew.c:        pNtk->Id = Vec_IntEntry( vOrder, pNtk->Id );
src/base/abc/abcHieNew.c:            assert( !pBox->Func || pBox->Func >= (unsigned)pNtk->Id );
src/base/abc/abcHieNew.c:        pNtk->nBoxes = Au_NtkBoxNum(pNtk);
src/base/abc/abcHieNew.c:        pNtk->nNodes = Au_NtkNodeNum(pNtk);
src/base/abc/abcHieNew.c:        pNtk->nPorts = Au_NtkPiNum(pNtk) + Au_NtkPoNum(pNtk);
src/base/abc/abcHieNew.c:        pNtk->nNodeAnds = Au_NtkNodeNumFunc( pNtk, 1 );
src/base/abc/abcHieNew.c:        pNtk->nNodeXors = Au_NtkNodeNumFunc( pNtk, 2 );
src/base/abc/abcHieNew.c:        pNtk->nNodeMuxs = Au_NtkNodeNumFunc( pNtk, 3 );
src/base/abc/abcHieNew.c://        assert( pNtk->nNodes == pNtk->nNodeAnds + pNtk->nNodeXors + pNtk->nNodeMuxs );
src/base/abc/abcHieNew.c://        printf( "adding %.0f nodes of model %s\n", pNtk->nNodes, Au_NtkName(pNtk) );
src/base/abc/abcHieNew.c:            assert( pBoxModel->Id > pNtk->Id );
src/base/abc/abcHieNew.c:            pNtk->nBoxes += pBoxModel->nBoxes;
src/base/abc/abcHieNew.c:            pNtk->nNodes += pBoxModel->nNodes;
src/base/abc/abcHieNew.c:            pNtk->nPorts += pBoxModel->nPorts;
src/base/abc/abcHieNew.c:            pNtk->nNodeAnds += pBoxModel->nNodeAnds;
src/base/abc/abcHieNew.c:            pNtk->nNodeXors += pBoxModel->nNodeXors;
src/base/abc/abcHieNew.c:            pNtk->nNodeMuxs += pBoxModel->nNodeMuxs;
src/base/abc/abcHieNew.c://        printf( "total %.0f nodes in model %s\n", pNtk->nNodes, Au_NtkName(pNtk) );
src/base/abc/abcHieNew.c:        pNtk->nNodes, pNtk->nBoxes, pNtk->nPorts );
src/base/abc/abcHieNew.c://        pNtk->nNodeAnds, pNtk->nNodeXors, pNtk->nNodeMuxs );
src/base/abc/abcHieNew.c:    printf( "Total ANDs  = %15.0f.\n", pNtk->nNodeAnds );
src/base/abc/abcHieNew.c:    printf( "Total XORs  = %15.0f.\n", pNtk->nNodeXors );
src/base/abc/abcHieNew.c:    printf( "Total MUXes = %15.0f.\n", pNtk->nNodeMuxs );
src/base/abc/abcHieNew.c:    if ( pNtk->pMan == NULL )
src/base/abc/abcHieNew.c:    vMods = &pNtk->pMan->vNtks;
src/base/abc/abcHieNew.c:    if ( pNtk->pMan == NULL )
src/base/abc/abcHieNew.c:    vMods = &pNtk->pMan->vNtks;
src/base/abc/abcHieNew.c:    if ( pNtk->pMan == NULL )
src/base/abc/abcHieNew.c:    vMods = &pNtk->pMan->vNtks;
src/base/abc/abcHieNew.c:        pMod->iStep = pNtk->Id;
src/base/abc/abcHieNew.c:    Au_ManCountThings( pNtk->pMan );
src/base/abc/abcHieNew.c:    if ( pNtk->pMan == NULL || pNtk->pMan->vNtks.pArray == NULL )
src/base/abc/abcHieNew.c:        Au_ManPrintStats( pNtk->pMan );
src/base/abc/abcHieNew.c:    Au_ManCountThings( pNtk->pMan );
src/base/abc/abcHieNew.c:        pNtkClp = Au_ManFindNtkP( pNtk->pMan, pModelName );
src/base/abc/abcHieNew.c:    Au_ManDelete( pNtk->pMan );
src/base/abc/abcLatch.c:        pMux->pData = Abc_SopRegister( (Mem_Flex_t *)pNtk->pManFunc, "11- 1\n0-1 1\n" );
src/base/abc/abcLatch.c:        pMux->pData = Cudd_bddIte((DdManager *)pNtk->pManFunc,Cudd_bddIthVar((DdManager *)pNtk->pManFunc,0),Cudd_bddIthVar((DdManager *)pNtk->pManFunc,1),Cudd_bddIthVar((DdManager *)pNtk->pManFunc,2)), Cudd_Ref( (DdNode *)pMux->pData );
src/base/abc/abcLatch.c:        pMux->pData = Hop_Mux((Hop_Man_t *)pNtk->pManFunc,Hop_IthVar((Hop_Man_t *)pNtk->pManFunc,0),Hop_IthVar((Hop_Man_t *)pNtk->pManFunc,1),Hop_IthVar((Hop_Man_t *)pNtk->pManFunc,2));
src/base/abc/abcLatch.c:            Nm_ManDeleteIdName( pLatch->pNtk->pManName, Abc_ObjFanout0(pLatch)->Id );
src/base/abc/abcLatch.c:    if ( pNtk->vOnehots == NULL )
src/base/abc/abcLatch.c:    vResult = Vec_PtrAlloc( Vec_PtrSize(pNtk->vOnehots) );
src/base/abc/abcLatch.c:    Vec_PtrForEachEntry( Vec_Ptr_t *, pNtk->vOnehots, vNames, i )
src/base/abc/abcLatch.c:            Num = Nm_ManFindIdByName( pNtk->pManName, pName, ABC_OBJ_BO );
src/base/abc/abcLatch.c:    pNtkNew = Abc_NtkStartFromNoLatches( pNtk, pNtk->ntkType, pNtk->ntkFunc );
src/base/abc/abc.h:static inline int         Abc_NtkIsNetlist( Abc_Ntk_t * pNtk )       { return pNtk->ntkType == ABC_NTK_NETLIST;     }
src/base/abc/abc.h:static inline int         Abc_NtkIsLogic( Abc_Ntk_t * pNtk )         { return pNtk->ntkType == ABC_NTK_LOGIC;       }
src/base/abc/abc.h:static inline int         Abc_NtkIsStrash( Abc_Ntk_t * pNtk )        { return pNtk->ntkType == ABC_NTK_STRASH;      }
src/base/abc/abc.h:static inline int         Abc_NtkHasSop( Abc_Ntk_t * pNtk )          { return pNtk->ntkFunc == ABC_FUNC_SOP;        }
src/base/abc/abc.h:static inline int         Abc_NtkHasBdd( Abc_Ntk_t * pNtk )          { return pNtk->ntkFunc == ABC_FUNC_BDD;        }
src/base/abc/abc.h:static inline int         Abc_NtkHasAig( Abc_Ntk_t * pNtk )          { return pNtk->ntkFunc == ABC_FUNC_AIG;        }
src/base/abc/abc.h:static inline int         Abc_NtkHasMapping( Abc_Ntk_t * pNtk )      { return pNtk->ntkFunc == ABC_FUNC_MAP;        }
src/base/abc/abc.h:static inline int         Abc_NtkHasBlifMv( Abc_Ntk_t * pNtk )       { return pNtk->ntkFunc == ABC_FUNC_BLIFMV;     }
src/base/abc/abc.h:static inline int         Abc_NtkHasBlackbox( Abc_Ntk_t * pNtk )     { return pNtk->ntkFunc == ABC_FUNC_BLACKBOX;   }
src/base/abc/abc.h:static inline int         Abc_NtkIsSopNetlist( Abc_Ntk_t * pNtk )    { return pNtk->ntkFunc == ABC_FUNC_SOP && pNtk->ntkType == ABC_NTK_NETLIST;  }
src/base/abc/abc.h:static inline int         Abc_NtkIsBddNetlist( Abc_Ntk_t * pNtk )    { return pNtk->ntkFunc == ABC_FUNC_BDD && pNtk->ntkType == ABC_NTK_NETLIST;  }
src/base/abc/abc.h:static inline int         Abc_NtkIsAigNetlist( Abc_Ntk_t * pNtk )    { return pNtk->ntkFunc == ABC_FUNC_AIG && pNtk->ntkType == ABC_NTK_NETLIST;  }
src/base/abc/abc.h:static inline int         Abc_NtkIsMappedNetlist( Abc_Ntk_t * pNtk ) { return pNtk->ntkFunc == ABC_FUNC_MAP && pNtk->ntkType == ABC_NTK_NETLIST;  }
src/base/abc/abc.h:static inline int         Abc_NtkIsBlifMvNetlist( Abc_Ntk_t * pNtk ) { return pNtk->ntkFunc == ABC_FUNC_BLIFMV && pNtk->ntkType == ABC_NTK_NETLIST;  }
src/base/abc/abc.h:static inline int         Abc_NtkIsSopLogic( Abc_Ntk_t * pNtk )      { return pNtk->ntkFunc == ABC_FUNC_SOP && pNtk->ntkType == ABC_NTK_LOGIC  ;  }
src/base/abc/abc.h:static inline int         Abc_NtkIsBddLogic( Abc_Ntk_t * pNtk )      { return pNtk->ntkFunc == ABC_FUNC_BDD && pNtk->ntkType == ABC_NTK_LOGIC  ;  }
src/base/abc/abc.h:static inline int         Abc_NtkIsAigLogic( Abc_Ntk_t * pNtk )      { return pNtk->ntkFunc == ABC_FUNC_AIG && pNtk->ntkType == ABC_NTK_LOGIC  ;  }
src/base/abc/abc.h:static inline int         Abc_NtkIsMappedLogic( Abc_Ntk_t * pNtk )   { return pNtk->ntkFunc == ABC_FUNC_MAP && pNtk->ntkType == ABC_NTK_LOGIC  ;  }
src/base/abc/abc.h:static inline char *      Abc_NtkName( Abc_Ntk_t * pNtk )            { return pNtk->pName;            }
src/base/abc/abc.h:static inline char *      Abc_NtkSpec( Abc_Ntk_t * pNtk )            { return pNtk->pSpec;            }
src/base/abc/abc.h:static inline Abc_Ntk_t * Abc_NtkExdc( Abc_Ntk_t * pNtk )            { return pNtk->pExdc;            }
src/base/abc/abc.h:static inline Abc_Ntk_t * Abc_NtkBackup( Abc_Ntk_t * pNtk )          { return pNtk->pNetBackup;       }
src/base/abc/abc.h:static inline int         Abc_NtkStep  ( Abc_Ntk_t * pNtk )          { return pNtk->iStep;            }
src/base/abc/abc.h:static inline void        Abc_NtkSetName  ( Abc_Ntk_t * pNtk, char * pName )           { pNtk->pName      = pName;      } 
src/base/abc/abc.h:static inline void        Abc_NtkSetSpec  ( Abc_Ntk_t * pNtk, char * pName )           { pNtk->pSpec      = pName;      } 
src/base/abc/abc.h:static inline void        Abc_NtkSetBackup( Abc_Ntk_t * pNtk, Abc_Ntk_t * pNetBackup ) { pNtk->pNetBackup = pNetBackup; }
src/base/abc/abc.h:static inline void        Abc_NtkSetStep  ( Abc_Ntk_t * pNtk, int iStep )              { pNtk->iStep      = iStep;      }
src/base/abc/abc.h:static inline int         Abc_NtkObjNum( Abc_Ntk_t * pNtk )          { return pNtk->nObjs;                        }
src/base/abc/abc.h:static inline int         Abc_NtkObjNumMax( Abc_Ntk_t * pNtk )       { return Vec_PtrSize(pNtk->vObjs);           }
src/base/abc/abc.h:static inline int         Abc_NtkPiNum( Abc_Ntk_t * pNtk )           { return Vec_PtrSize(pNtk->vPis);            }
src/base/abc/abc.h:static inline int         Abc_NtkPoNum( Abc_Ntk_t * pNtk )           { return Vec_PtrSize(pNtk->vPos);            }
src/base/abc/abc.h:static inline int         Abc_NtkCiNum( Abc_Ntk_t * pNtk )           { return Vec_PtrSize(pNtk->vCis);            }
src/base/abc/abc.h:static inline int         Abc_NtkCoNum( Abc_Ntk_t * pNtk )           { return Vec_PtrSize(pNtk->vCos);            }
src/base/abc/abc.h:static inline int         Abc_NtkBoxNum( Abc_Ntk_t * pNtk )          { return Vec_PtrSize(pNtk->vBoxes);          }
src/base/abc/abc.h:static inline int         Abc_NtkBiNum( Abc_Ntk_t * pNtk )           { return pNtk->nObjCounts[ABC_OBJ_BI];       }
src/base/abc/abc.h:static inline int         Abc_NtkBoNum( Abc_Ntk_t * pNtk )           { return pNtk->nObjCounts[ABC_OBJ_BO];       }
src/base/abc/abc.h:static inline int         Abc_NtkNetNum( Abc_Ntk_t * pNtk )          { return pNtk->nObjCounts[ABC_OBJ_NET];      }
src/base/abc/abc.h:static inline int         Abc_NtkNodeNum( Abc_Ntk_t * pNtk )         { return pNtk->nObjCounts[ABC_OBJ_NODE];     }
src/base/abc/abc.h:static inline int         Abc_NtkLatchNum( Abc_Ntk_t * pNtk )        { return pNtk->nObjCounts[ABC_OBJ_LATCH];    }
src/base/abc/abc.h:static inline int         Abc_NtkWhiteboxNum( Abc_Ntk_t * pNtk )     { return pNtk->nObjCounts[ABC_OBJ_WHITEBOX]; }
src/base/abc/abc.h:static inline int         Abc_NtkBlackboxNum( Abc_Ntk_t * pNtk )     { return pNtk->nObjCounts[ABC_OBJ_BLACKBOX]; }
src/base/abc/abc.h:static inline int         Abc_NtkConstrNum( Abc_Ntk_t * pNtk )       { return pNtk->nConstrs;                     }
src/base/abc/abc.h:static inline Abc_Obj_t * Abc_NtkObj( Abc_Ntk_t * pNtk, int i )      { return (Abc_Obj_t *)Vec_PtrEntry( pNtk->vObjs, i );   }
src/base/abc/abc.h:static inline Abc_Obj_t * Abc_NtkPi( Abc_Ntk_t * pNtk, int i )       { return (Abc_Obj_t *)Vec_PtrEntry( pNtk->vPis, i );    }
src/base/abc/abc.h:static inline Abc_Obj_t * Abc_NtkPo( Abc_Ntk_t * pNtk, int i )       { return (Abc_Obj_t *)Vec_PtrEntry( pNtk->vPos, i );    }
src/base/abc/abc.h:static inline Abc_Obj_t * Abc_NtkCi( Abc_Ntk_t * pNtk, int i )       { return (Abc_Obj_t *)Vec_PtrEntry( pNtk->vCis, i );    }
src/base/abc/abc.h:static inline Abc_Obj_t * Abc_NtkCo( Abc_Ntk_t * pNtk, int i )       { return (Abc_Obj_t *)Vec_PtrEntry( pNtk->vCos, i );    }
src/base/abc/abc.h:static inline Abc_Obj_t * Abc_NtkBox( Abc_Ntk_t * pNtk, int i )      { return (Abc_Obj_t *)Vec_PtrEntry( pNtk->vBoxes, i );  }
src/base/abc/abc.h:static inline void        Abc_ObjBlackboxToWhitebox( Abc_Obj_t * pObj ) { assert( Abc_ObjIsBlackbox(pObj) ); pObj->Type = ABC_OBJ_WHITEBOX; pObj->pNtk->nObjCounts[ABC_OBJ_BLACKBOX]--; pObj->pNtk->nObjCounts[ABC_OBJ_WHITEBOX]++; }
src/base/abc/abc.h:static inline Abc_Obj_t * Abc_ObjFanout( Abc_Obj_t * pObj, int i )   { return (Abc_Obj_t *)pObj->pNtk->vObjs->pArray[ pObj->vFanouts.pArray[i] ];  }
src/base/abc/abc.h:static inline Abc_Obj_t * Abc_ObjFanout0( Abc_Obj_t * pObj )         { return (Abc_Obj_t *)pObj->pNtk->vObjs->pArray[ pObj->vFanouts.pArray[0] ];  }
src/base/abc/abc.h:static inline Abc_Obj_t * Abc_ObjFanin( Abc_Obj_t * pObj, int i )    { return (Abc_Obj_t *)pObj->pNtk->vObjs->pArray[ pObj->vFanins.pArray[i] ];   }
src/base/abc/abc.h:static inline Abc_Obj_t * Abc_ObjFanin0( Abc_Obj_t * pObj )          { return (Abc_Obj_t *)pObj->pNtk->vObjs->pArray[ pObj->vFanins.pArray[0] ];   }
src/base/abc/abc.h:static inline Abc_Obj_t * Abc_ObjFanin1( Abc_Obj_t * pObj )          { return (Abc_Obj_t *)pObj->pNtk->vObjs->pArray[ pObj->vFanins.pArray[1] ];   }
src/base/abc/abc.h:static inline int         Abc_ObjFaninPhase( Abc_Obj_t * p, int i )  { assert(p->pNtk->vPhases); assert( i >= 0 && i < Abc_ObjFaninNum(p) ); return (Vec_IntEntry(p->pNtk->vPhases, Abc_ObjId(p)) >> i) & 1;  } 
src/base/abc/abc.h:static inline void        Abc_ObjFaninFlipPhase( Abc_Obj_t * p,int i){ assert(p->pNtk->vPhases); assert( i >= 0 && i < Abc_ObjFaninNum(p) ); *Vec_IntEntryP(p->pNtk->vPhases, Abc_ObjId(p)) ^= (1 << i);      } 
src/base/abc/abc.h:static inline void *      Abc_NtkGlobalBdd( Abc_Ntk_t * pNtk )          { return Vec_PtrEntry(pNtk->vAttrs, VEC_ATTR_GLOBAL_BDD);                                   }
src/base/abc/abc.h:static inline void *      Abc_NtkMvVar( Abc_Ntk_t * pNtk )              { return Vec_PtrEntry(pNtk->vAttrs, VEC_ATTR_MVVAR);                                        }
src/base/abc/abc.h:    for ( i = 0; (i < Abc_NtkCoNum(pNtk)) && (((pCo) = Abc_NtkCo(pNtk, i < pNtk->nBarBufs ? Abc_NtkCoNum(pNtk) - pNtk->nBarBufs + i : i - pNtk->nBarBufs)), 1); i++ )
src/base/abc/abcFunc.c:    Mem_FlexStop( (Mem_Flex_t *)pNtk->pManFunc, 0 );
src/base/abc/abcFunc.c:    pNtk->pManFunc = dd;
src/base/abc/abcFunc.c:    pNtk->ntkFunc = ABC_FUNC_BDD;
src/base/abc/abcFunc.c:    DdManager * dd = (DdManager *)pNtk->pManFunc;
src/base/abc/abcFunc.c:    pNtk->ntkFunc = ABC_FUNC_SOP;
src/base/abc/abcFunc.c:    pNtk->pManFunc = pManNew;
src/base/abc/abcFunc.c:    *ppSop0 = Abc_ConvertBddToSop( pMmMan, (DdManager *)pNode->pNtk->pManFunc, (DdNode *)pNode->pData, (DdNode *)pNode->pData, Abc_ObjFaninNum(pNode), fAllPrimes, vCube, 0 );
src/base/abc/abcFunc.c:    *ppSop1 = Abc_ConvertBddToSop( pMmMan, (DdManager *)pNode->pNtk->pManFunc, (DdNode *)pNode->pData, (DdNode *)pNode->pData, Abc_ObjFaninNum(pNode), fAllPrimes, vCube, 1 );
src/base/abc/abcFunc.c:            pNode->pData = Abc_ConvertBddToSop( (Mem_Flex_t *)pNtk->pManFunc, dd, bFunc, bFunc, Abc_ObjFaninNum(pNode), 0, vCube, 1 );
src/base/abc/abcFunc.c:    pMan = (Hop_Man_t *)pNtk->pManFunc;
src/base/abc/abcFunc.c:    Hop_ManStop( (Hop_Man_t *)pNtk->pManFunc );
src/base/abc/abcFunc.c:    pNtk->pManFunc = dd;
src/base/abc/abcFunc.c:    pNtk->ntkFunc = ABC_FUNC_BDD;
src/base/abc/abcFunc.c:    Mem_FlexStop( (Mem_Flex_t *)pNtk->pManFunc, 0 );
src/base/abc/abcFunc.c:    pNtk->pManFunc = pMan;
src/base/abc/abcFunc.c:    pNtk->ntkFunc = ABC_FUNC_AIG;
src/base/abc/abcFunc.c:    pHopMan = (Hop_Man_t *)pObjOld->pNtk->pManFunc;
src/base/abc/abcFunc.c:    assert( pNtk->pManFunc == Abc_FrameReadLibGen() );
src/base/abc/abcFunc.c:    pNtk->pManFunc = Mem_FlexStart();
src/base/abc/abcFunc.c:        pNode->pData = Abc_SopRegister( (Mem_Flex_t *)pNtk->pManFunc, pSop );
src/base/abc/abcFunc.c:    pNtk->ntkFunc  = ABC_FUNC_SOP;
src/base/abc/abcNames.c:    return Nm_ManCreateUniqueName( pObj->pNtk->pManName, pObj->Id );
src/base/abc/abcNames.c:    return Nm_ManStoreIdName( pObj->pNtk->pManName, pObj->Id, pObj->Type, pName, pSuffix );
src/base/abc/abcNames.c:    assert( Nm_ManNumEntries(pNtk->pManName) > 0 );
src/base/abc/abcNames.c:    assert( Nm_ManNumEntries(pNtk->pManName) > 0 );
src/base/abc/abcNames.c:    qsort( (void *)Vec_PtrArray(pNtk->vPis), (size_t)Vec_PtrSize(pNtk->vPis), sizeof(Abc_Obj_t *), 
src/base/abc/abcNames.c:    qsort( (void *)Vec_PtrArray(pNtk->vPos), (size_t)Vec_PtrSize(pNtk->vPos), sizeof(Abc_Obj_t *), 
src/base/abc/abcNames.c:        qsort( (void *)Vec_PtrArray(pNtk->vBoxes), (size_t)Vec_PtrSize(pNtk->vBoxes), sizeof(Abc_Obj_t *), 
src/base/abc/abcNames.c:    Nm_ManFree( pNtk->pManName );
src/base/abc/abcNames.c:    pNtk->pManName = Nm_ManCreate( Abc_NtkCiNum(pNtk) + Abc_NtkCoNum(pNtk) + Abc_NtkBoxNum(pNtk) );
src/base/abc/abcNames.c:    Nm_ManFree( pNtk->pManName );
src/base/abc/abcNames.c:    pNtk->pManName = pManName;
src/base/abc/abcNames.c:        int nCiId = Nm_ManFindIdByNameTwoTypes( pNtk->pManName, Abc_ObjName(pObj), ABC_OBJ_PI, ABC_OBJ_BO );
src/base/abc/abcNames.c:    Nm_ManFree( pNtk->pManName );
src/base/abc/abcNames.c:    pNtk->pManName = Nm_ManCreate( Abc_NtkCiNum(pNtk) + Abc_NtkCoNum(pNtk) + Abc_NtkBoxNum(pNtk) );
src/base/abc/abcFanOrder.c:    pNode->pData = Abc_SopCreateOr( (Mem_Flex_t *)pNode->pNtk->pManFunc, 2, NULL );
src/base/abc/abcHie.c:        if ( Nm_ManFindNameById(pNet->pCopy->pNtk->pManName, pNet->pCopy->Id) )
src/base/abc/abcHie.c:            Nm_ManDeleteIdName(pNet->pCopy->pNtk->pManName, pNet->pCopy->Id);
src/base/abc/abcHie.c:    pNtkNew = Abc_NtkAlloc( pNtk->ntkType, pNtk->ntkFunc, 1 );
src/base/abc/abcHie.c:    pNtkNew->pName = Abc_UtilStrsav(pNtk->pName);
src/base/abc/abcHie.c:    pNtkNew->pSpec = Abc_UtilStrsav(pNtk->pSpec);
src/base/abc/abcHie.c:    if ( pNtk->pDesign )
src/base/abc/abcHie.c:        assert( Vec_PtrEntry(pNtk->pDesign->vTops, 0) == pNtk );
src/base/abc/abcHie.c:        pNtkNew->pDesign = Abc_DesDupBlackboxes( pNtk->pDesign, pNtkNew );
src/base/abc/abcHie.c:    if ( pNtk->pExdc )
src/base/abc/abcHie.c:        //printf( "Flatting black box \"%s\".\n", pNtk->pName );
src/base/abc/abcHie.c:        if ( Nm_ManFindNameById(pNet->pCopy->pNtk->pManName, pNet->pCopy->Id) )
src/base/abc/abcHie.c:            Nm_ManDeleteIdName(pNet->pCopy->pNtk->pManName, pNet->pCopy->Id);
src/base/abc/abcHie.c:    if ( pNtk->pDesign == NULL || pNtk->pDesign->vModules == NULL )
src/base/abc/abcHie.c:    vMods = pNtk->pDesign->vModules;
src/base/abc/abcHie.c:    pNtkNew = Abc_NtkAlloc( pNtk->ntkType, pNtk->ntkFunc, 1 );
src/base/abc/abcHie.c:    pNtkNew->pName = Extra_UtilStrsav(pNtk->pName);
src/base/abc/abcHie.c:    pNtkNew->pSpec = Extra_UtilStrsav(pNtk->pSpec);
src/base/abc/abcHie.c:    if ( pNtk->pDesign )
src/base/abc/abcHie.c:        assert( Vec_PtrEntry(pNtk->pDesign->vTops, 0) == pNtk );
src/base/abc/abcHie.c:        pNtkNew->pDesign = Abc_DesDupBlackboxes( pNtk->pDesign, pNtkNew );
src/base/abc/abcHie.c:    if ( pNtk->pExdc )
src/base/abc/abcHie.c:    pNtkNew = Abc_NtkAlloc( pNtk->ntkType, pNtk->ntkFunc, 1 );
src/base/abc/abcHie.c:    pNtkNew->pName = Extra_UtilStrsav( pNtk->pName );
src/base/abc/abcHie.c:    pNtkNew->pSpec = Extra_UtilStrsav( pNtk->pSpec );
src/bool/dec/decAbc.c:        pNode->pFunc = Abc_AigAnd( (Abc_Aig_t *)pNtk->pManFunc, pAnd0, pAnd1 );
src/bool/dec/decAbc.c://        pNode->pFunc = Abc_AigAnd( (Abc_Aig_t *)pNtk->pManFunc, pAnd0, pAnd1 );
src/bool/dec/decAbc.c:    Abc_Aig_t * pMan = (Abc_Aig_t *)pRoot->pNtk->pManFunc;
src/bool/dec/decAbc.c:    RetValue = Abc_AigReplace( (Abc_Aig_t *)pNtk->pManFunc, pRoot, pRootNew, fUpdateLevel );
src/bool/kit/kitDsd.c:    pObj->Id = pNtk->nVars + pNtk->nNodes;
src/bool/kit/kitDsd.c:    if ( pNtk->nNodes == pNtk->nNodesAlloc )
src/bool/kit/kitDsd.c:        pNtk->nNodesAlloc *= 2;
src/bool/kit/kitDsd.c:        pNtk->pNodes = ABC_REALLOC( Kit_DsdObj_t *, pNtk->pNodes, pNtk->nNodesAlloc ); 
src/bool/kit/kitDsd.c:    assert( pNtk->nNodes < pNtk->nNodesAlloc );
src/bool/kit/kitDsd.c:    pNtk->pNodes[pNtk->nNodes++] = pObj;
src/bool/kit/kitDsd.c:    pNtk->pNodes = ABC_ALLOC( Kit_DsdObj_t *, nVars+1 );
src/bool/kit/kitDsd.c:    pNtk->nVars = nVars;
src/bool/kit/kitDsd.c:    pNtk->nNodesAlloc = nVars+1;
src/bool/kit/kitDsd.c:    pNtk->pMem = ABC_ALLOC( unsigned, 6 * Kit_TruthWordNum(nVars) );
src/bool/kit/kitDsd.c:    ABC_FREE( pNtk->pSupps );
src/bool/kit/kitDsd.c:    ABC_FREE( pNtk->pNodes );
src/bool/kit/kitDsd.c:    ABC_FREE( pNtk->pMem );
src/bool/kit/kitDsd.c:        assert( Id < pNtk->nVars );
src/bool/kit/kitDsd.c:    if ( Abc_LitIsCompl(pNtk->Root) )
src/bool/kit/kitDsd.c:    Kit_DsdPrint2_rec( pFile, pNtk, Abc_Lit2Var(pNtk->Root) );
src/bool/kit/kitDsd.c:        assert( Id < pNtk->nVars );
src/bool/kit/kitDsd.c:    if ( Abc_LitIsCompl(pNtk->Root) )
src/bool/kit/kitDsd.c:    Kit_DsdPrint_rec( pFile, pNtk, Abc_Lit2Var(pNtk->Root) );
src/bool/kit/kitDsd.c:        assert( Id < pNtk->nVars );
src/bool/kit/kitDsd.c:    if ( Abc_LitIsCompl(pNtk->Root) )
src/bool/kit/kitDsd.c:    pBuff = Kit_DsdWrite_rec( pBuff, pNtk, Abc_Lit2Var(pNtk->Root) );
src/bool/kit/kitDsd.c:        assert( Id < pNtk->nVars );
src/bool/kit/kitDsd.c:        Kit_TruthFill( pTruthRes, pNtk->nVars );
src/bool/kit/kitDsd.c:            Kit_TruthNot( pTruthRes, pTruthFans[0], pNtk->nVars );
src/bool/kit/kitDsd.c:            Kit_TruthCopy( pTruthRes, pTruthFans[0], pNtk->nVars );
src/bool/kit/kitDsd.c:        Kit_TruthFill( pTruthRes, pNtk->nVars );
src/bool/kit/kitDsd.c:            Kit_TruthAndPhase( pTruthRes, pTruthRes, pTruthFans[i], pNtk->nVars, 0, Abc_LitIsCompl(iLit) );
src/bool/kit/kitDsd.c:        Kit_TruthClear( pTruthRes, pNtk->nVars );
src/bool/kit/kitDsd.c:            Kit_TruthXor( pTruthRes, pTruthRes, pTruthFans[i], pNtk->nVars );
src/bool/kit/kitDsd.c:            Kit_TruthNot( pTruthRes, pTruthRes, pNtk->nVars );
src/bool/kit/kitDsd.c:    pTruthMint = Vec_PtrEntry(p->vTtNodes, pNtk->nVars + pNtk->nNodes);
src/bool/kit/kitDsd.c:    Kit_TruthClear( pTruthRes, pNtk->nVars );
src/bool/kit/kitDsd.c:        Kit_TruthFill( pTruthMint, pNtk->nVars );
src/bool/kit/kitDsd.c:            Kit_TruthAndPhase( pTruthMint, pTruthMint, pTruthFans[i], pNtk->nVars, 0, ((m & (1<<i)) == 0) ^ Abc_LitIsCompl(iLit) );
src/bool/kit/kitDsd.c:        Kit_TruthOr( pTruthRes, pTruthRes, pTruthMint, pNtk->nVars );
src/bool/kit/kitDsd.c:            Kit_TruthNot( pTruthFans[i], pTruthFans[i], pNtk->nVars );
src/bool/kit/kitDsd.c:    pTruthTemp = Kit_TruthCompose( p->dd, Kit_DsdObjTruth(pObj), pObj->nFans, pTruthFans, pNtk->nVars, p->vTtBdds, p->vNodes );
src/bool/kit/kitDsd.c:    Kit_TruthCopy( pTruthRes, pTruthTemp, pNtk->nVars );
src/bool/kit/kitDsd.c:    assert( pNtk->nVars <= p->nVars );
src/bool/kit/kitDsd.c:    for ( i = 0; i < (int)pNtk->nVars; i++ )
src/bool/kit/kitDsd.c:    pTruthRes = Kit_DsdTruthComputeNode_rec( p, pNtk, Abc_Lit2Var(pNtk->Root) );
src/bool/kit/kitDsd.c:    if ( Abc_LitIsCompl(pNtk->Root) )
src/bool/kit/kitDsd.c:        Kit_TruthNot( pTruthRes, pTruthRes, pNtk->nVars );
src/bool/kit/kitDsd.c:        assert( Id < pNtk->nVars );
src/bool/kit/kitDsd.c:        Kit_TruthFill( pTruthRes, pNtk->nVars );
src/bool/kit/kitDsd.c:            Kit_TruthNot( pTruthRes, pTruthFans[0], pNtk->nVars );
src/bool/kit/kitDsd.c:            Kit_TruthCopy( pTruthRes, pTruthFans[0], pNtk->nVars );
src/bool/kit/kitDsd.c:        Kit_TruthFill( pTruthRes, pNtk->nVars );
src/bool/kit/kitDsd.c:                Kit_TruthAndPhase( pTruthRes, pTruthRes, pTruthFans[i], pNtk->nVars, 0, Abc_LitIsCompl(iLit) );
src/bool/kit/kitDsd.c:        Kit_TruthClear( pTruthRes, pNtk->nVars );
src/bool/kit/kitDsd.c:                Kit_TruthXor( pTruthRes, pTruthRes, pTruthFans[i], pNtk->nVars );
src/bool/kit/kitDsd.c:            Kit_TruthNot( pTruthRes, pTruthRes, pNtk->nVars );
src/bool/kit/kitDsd.c:    pTruthMint = Vec_PtrEntry(p->vTtNodes, pNtk->nVars + pNtk->nNodes);
src/bool/kit/kitDsd.c:    Kit_TruthClear( pTruthRes, pNtk->nVars );
src/bool/kit/kitDsd.c:        Kit_TruthFill( pTruthMint, pNtk->nVars );
src/bool/kit/kitDsd.c:            Kit_TruthAndPhase( pTruthMint, pTruthMint, pTruthFans[i], pNtk->nVars, 0, ((m & (1<<i)) == 0) ^ Abc_LitIsCompl(iLit) );
src/bool/kit/kitDsd.c:        Kit_TruthOr( pTruthRes, pTruthRes, pTruthMint, pNtk->nVars );
src/bool/kit/kitDsd.c:            Kit_TruthNot( pTruthFans[i], pTruthFans[i], pNtk->nVars );
src/bool/kit/kitDsd.c:    pTruthTemp = Kit_TruthCompose( p->dd, Kit_DsdObjTruth(pObj), pObj->nFans, pTruthFans, pNtk->nVars, p->vTtBdds, p->vNodes );
src/bool/kit/kitDsd.c:    Kit_TruthCopy( pTruthRes, pTruthTemp, pNtk->nVars );
src/bool/kit/kitDsd.c:    assert( pNtk->nVars <= p->nVars );
src/bool/kit/kitDsd.c:    for ( i = 0; i < (int)pNtk->nVars; i++ )
src/bool/kit/kitDsd.c:    pTruthRes = Kit_DsdTruthComputeNodeOne_rec( p, pNtk, Abc_Lit2Var(pNtk->Root), uSupp );
src/bool/kit/kitDsd.c:    if ( Abc_LitIsCompl(pNtk->Root) )
src/bool/kit/kitDsd.c:        Kit_TruthNot( pTruthRes, pTruthRes, pNtk->nVars );
src/bool/kit/kitDsd.c:        assert( Id < pNtk->nVars );
src/bool/kit/kitDsd.c:            Kit_TruthFill( pTruthRes, pNtk->nVars );
src/bool/kit/kitDsd.c:                Kit_TruthAndPhase( pTruthRes, pTruthRes, pTruthFans[i], pNtk->nVars, 0, Abc_LitIsCompl(iLit) );
src/bool/kit/kitDsd.c:            Kit_TruthClear( pTruthRes, pNtk->nVars );
src/bool/kit/kitDsd.c:                Kit_TruthXor( pTruthRes, pTruthRes, pTruthFans[i], pNtk->nVars );
src/bool/kit/kitDsd.c:                Kit_TruthNot( pTruthRes, pTruthRes, pNtk->nVars );
src/bool/kit/kitDsd.c:            Kit_TruthIthVar( pTruthRes, pNtk->nVars, iVar );
src/bool/kit/kitDsd.c:            Kit_TruthFill( pTruthDec, pNtk->nVars );
src/bool/kit/kitDsd.c:                    Kit_TruthAndPhase( pTruthDec, pTruthDec, pTruthFans[i], pNtk->nVars, 0, Abc_LitIsCompl(iLit) );
src/bool/kit/kitDsd.c:                    Kit_TruthAndPhase( pTruthRes, pTruthRes, pTruthFans[i], pNtk->nVars, 0, Abc_LitIsCompl(iLit) );
src/bool/kit/kitDsd.c:            Kit_TruthIthVar( pTruthRes, pNtk->nVars, iVar );
src/bool/kit/kitDsd.c:            Kit_TruthClear( pTruthDec, pNtk->nVars );
src/bool/kit/kitDsd.c:                    Kit_TruthXor( pTruthDec, pTruthDec, pTruthFans[i], pNtk->nVars );
src/bool/kit/kitDsd.c:                    Kit_TruthXor( pTruthRes, pTruthRes, pTruthFans[i], pNtk->nVars );
src/bool/kit/kitDsd.c:                Kit_TruthNot( pTruthRes, pTruthRes, pNtk->nVars );
src/bool/kit/kitDsd.c:        Kit_TruthCopy( pTruthDec, pTruthFans[i], pNtk->nVars );
src/bool/kit/kitDsd.c:        Kit_TruthIthVar( pTruthFans[i], pNtk->nVars, iVar );
src/bool/kit/kitDsd.c:    pTruthMint = Vec_PtrEntry(p->vTtNodes, pNtk->nVars + pNtk->nNodes);
src/bool/kit/kitDsd.c:    Kit_TruthClear( pTruthRes, pNtk->nVars );
src/bool/kit/kitDsd.c:        Kit_TruthFill( pTruthMint, pNtk->nVars );
src/bool/kit/kitDsd.c:            Kit_TruthAndPhase( pTruthMint, pTruthMint, pTruthFans[i], pNtk->nVars, 0, ((m & (1<<i)) == 0) ^ Abc_LitIsCompl(iLit) );
src/bool/kit/kitDsd.c:        Kit_TruthOr( pTruthRes, pTruthRes, pTruthMint, pNtk->nVars );
src/bool/kit/kitDsd.c:            Kit_TruthNot( pTruthFans[i], pTruthFans[i], pNtk->nVars );
src/bool/kit/kitDsd.c:    pTruthTemp = Kit_TruthCompose( p->dd, Kit_DsdObjTruth(pObj), pObj->nFans, pTruthFans, pNtk->nVars, p->vTtBdds, p->vNodes );
src/bool/kit/kitDsd.c:    Kit_TruthCopy( pTruthRes, pTruthTemp, pNtk->nVars );
src/bool/kit/kitDsd.c:    assert( pNtk->nVars <= p->nVars );
src/bool/kit/kitDsd.c:        Kit_TruthClear( pTruthDec, pNtk->nVars );
src/bool/kit/kitDsd.c:        Kit_TruthCopy( pTruthDec, pTruthRes, pNtk->nVars );
src/bool/kit/kitDsd.c:        Kit_TruthIthVar( pTruthRes, pNtk->nVars, iVar );
src/bool/kit/kitDsd.c:    for ( i = 0; i < (int)pNtk->nVars; i++ )
src/bool/kit/kitDsd.c:    pTruthRes = Kit_DsdTruthComputeNodeTwo_rec( p, pNtk, Abc_Lit2Var(pNtk->Root), uSupp, iVar, pTruthDec );
src/bool/kit/kitDsd.c:    if ( Abc_LitIsCompl(pNtk->Root) )
src/bool/kit/kitDsd.c:        Kit_TruthNot( pTruthRes, pTruthRes, pNtk->nVars );
src/bool/kit/kitDsd.c:    p = Kit_DsdManAlloc( pNtk->nVars, Kit_DsdNtkObjNum(pNtk) );
src/bool/kit/kitDsd.c:    Kit_TruthCopy( pTruthRes, pTruth, pNtk->nVars );
src/bool/kit/kitDsd.c:        Kit_TruthCopy( pTruthCo, pTruth, pNtk->nVars );
src/bool/kit/kitDsd.c:    Kit_TruthCopy( pTruthRes, pTruth, pNtk->nVars );
src/bool/kit/kitDsd.c:        unsigned * pTruthTemp = Vec_PtrEntry(p->vTtNodes, pNtk->nVars + pNtk->nNodes + 1);
src/bool/kit/kitDsd.c:        pNtk->pSupps = NULL;
src/bool/kit/kitDsd.c://        if ( !Kit_TruthIsEqual( pTruthTemp, pTruthRes, pNtk->nVars ) )
src/bool/kit/kitDsd.c:        if ( !Kit_TruthIsEqualWithPhase( pTruthTemp, pTruthRes, pNtk->nVars ) )
src/bool/kit/kitDsd.c:            Kit_DsdPrintFromTruth( pTruthRes, pNtk->nVars );
src/bool/kit/kitDsd.c:            Kit_DsdPrintFromTruth( pTruthTemp, pNtk->nVars );
src/bool/kit/kitDsd.c:    Kit_DsdCountLuts_rec( pNtk, nLutSize, Abc_Lit2Var(pNtk->Root), &Counter );
src/bool/kit/kitDsd.c://    ABC_FREE( pNtk->pSupps );
src/bool/kit/kitDsd.c:    return Kit_DsdFindLargeBox_rec( pNtk, Abc_Lit2Var(pNtk->Root), Size );
src/bool/kit/kitDsd.c:    return Kit_DsdCountAigNodes_rec( pNtk, Abc_Lit2Var(pNtk->Root) );
src/bool/kit/kitDsd.c:    for ( i = 0; i < pNtk->nNodes; i++ )
src/bool/kit/kitDsd.c:        pObj = pNtk->pNodes[i];
src/bool/kit/kitDsd.c:    unsigned * pCofs2[2] = { pNtk->pMem, pNtk->pMem + nWords };
src/bool/kit/kitDsd.c:    unsigned * pCofs4[2][2] = { {pNtk->pMem + 2 * nWords, pNtk->pMem + 3 * nWords}, {pNtk->pMem + 4 * nWords, pNtk->pMem + 5 * nWords} };
src/bool/kit/kitDsd.c:        Kit_TruthShrink( pNtk->pMem, pTruth, nFansNew, pObj->nFans, uSupp, 1 );
src/bool/kit/kitDsd.c:    pNtk->Root = Abc_Var2Lit( pNtk->nVars, 0 );
src/bool/kit/kitDsd.c:    assert( pNtk->pNodes[0] == pObj );
src/bool/kit/kitDsd.c:             pNtk->Root = Abc_LitNot(pNtk->Root);
src/bool/kit/kitDsd.c:    Kit_DsdDecompose_rec( pNtk, pNtk->pNodes[0], uSupp, &pNtk->Root, nDecMux );
src/bool/kit/kitDsd.c:    unsigned * pCofs2[2] = { pNtk->pMem, pNtk->pMem + Kit_TruthWordNum(pNtk->nVars) };
src/bool/kit/kitDsd.c://    assert( pRoot->nFans == pNtk->nVars );
src/bool/kit/kitDsd.c://        Extra_PrintBinary( stdout, pTruth, (1 << pNtk->nVars) ); 
src/bool/kit/kitDsd.c:        Extra_PrintHexadecimal( stdout, pTruth, pNtk->nVars ); 
src/bool/kit/kitDsd.c:    for ( i = 0; i < pNtk->nVars; i++ )
src/bool/kit/kitDsd.c:        Kit_TruthCofactor0New( pCofs2[0], pTruth, pNtk->nVars, i );
src/bool/kit/kitDsd.c:        pNtk0 = Kit_DsdDecompose( pCofs2[0], pNtk->nVars );
src/bool/kit/kitDsd.c:        Kit_TruthCofactor1New( pCofs2[1], pTruth, pNtk->nVars, i );
src/bool/kit/kitDsd.c:        pNtk1 = Kit_DsdDecompose( pCofs2[1], pNtk->nVars );
src/bool/kit/kitDsd.c://    if ( Kit_DsdFindLargeBox(pNtk, Abc_Lit2Var(pNtk->Root)) )
src/bool/kit/kitDsd.c://    if ( Kit_DsdFindLargeBox(pNtk, Abc_Lit2Var(pNtk->Root)) )
src/bool/kit/kit.h:static inline int             Kit_DsdNtkObjNum( Kit_DsdNtk_t * pNtk ){ return pNtk->nVars + pNtk->nNodes; }
src/bool/kit/kit.h:static inline Kit_DsdObj_t *  Kit_DsdNtkObj( Kit_DsdNtk_t * pNtk, int Id )      { assert( Id >= 0 && Id < pNtk->nVars + pNtk->nNodes ); return Id < pNtk->nVars ? NULL : pNtk->pNodes[Id - pNtk->nVars]; }
src/bool/kit/kit.h:static inline Kit_DsdObj_t *  Kit_DsdNtkRoot( Kit_DsdNtk_t * pNtk )             { return Kit_DsdNtkObj( pNtk, Abc_Lit2Var(pNtk->Root) );                      }
src/bool/kit/kit.h:static inline int             Kit_DsdLitIsLeaf( Kit_DsdNtk_t * pNtk, int Lit )   { int Id = Abc_Lit2Var(Lit); assert( Id >= 0 && Id < pNtk->nVars + pNtk->nNodes ); return Id < pNtk->nVars; }
src/bool/kit/kit.h:static inline unsigned        Kit_DsdLitSupport( Kit_DsdNtk_t * pNtk, int Lit )  { int Id = Abc_Lit2Var(Lit); assert( Id >= 0 && Id < pNtk->nVars + pNtk->nNodes ); return pNtk->pSupps? (Id < pNtk->nVars? (1 << Id) : pNtk->pSupps[Id - pNtk->nVars]) : 0; }
src/sat/csat/csat_apis.c:    mng->pNtk->pName = Extra_UtilStrsav("csat_network");
src/sat/csat/csat_apis.c:                pSop = Abc_SopCreateConst1( (Mem_Flex_t *)mng->pNtk->pManFunc );
src/sat/csat/csat_apis.c:                pSop = Abc_SopCreateAnd( (Mem_Flex_t *)mng->pNtk->pManFunc, nofi, NULL );
src/sat/csat/csat_apis.c:                pSop = Abc_SopCreateNand( (Mem_Flex_t *)mng->pNtk->pManFunc, nofi );
src/sat/csat/csat_apis.c:                pSop = Abc_SopCreateOr( (Mem_Flex_t *)mng->pNtk->pManFunc, nofi, NULL );
src/sat/csat/csat_apis.c:                pSop = Abc_SopCreateNor( (Mem_Flex_t *)mng->pNtk->pManFunc, nofi );
src/sat/csat/csat_apis.c:                pSop = Abc_SopCreateXor( (Mem_Flex_t *)mng->pNtk->pManFunc, nofi );
src/sat/csat/csat_apis.c:                pSop = Abc_SopCreateNxor( (Mem_Flex_t *)mng->pNtk->pManFunc, nofi );
src/sat/csat/csat_apis.c:                pSop = Abc_SopCreateInv( (Mem_Flex_t *)mng->pNtk->pManFunc );
src/sat/csat/csat_apis.c:                pSop = Abc_SopCreateBuf( (Mem_Flex_t *)mng->pNtk->pManFunc );
src/sat/bmc/bmcExpand.c:        pObj->pData = Abc_SopRegister( (Mem_Flex_t *)pNtk->pManFunc, Vec_StrArray(vSop) );
